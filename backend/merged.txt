crr.js
// merge.js
const fs = require('fs').promises;
const path = require('path');
const readline = require('readline');

// Only include these extensions
const ALLOWED_EXT = new Set(['.js', '.html', '.env', '.css','.ts','.tsx',]);
// Directory names to ignore
const IGNORE_DIR = new Set(['node_modules','.next','public']);

async function collectFiles(dir, ignoreFiles) {
  let results = [];
  const entries = await fs.readdir(dir, { withFileTypes: true });

  for (let entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (IGNORE_DIR.has(entry.name)) continue;
      results = results.concat(await collectFiles(fullPath, ignoreFiles));

    } else {
      const ext = path.extname(entry.name).toLowerCase();
      // skip unwanted extensions or explicitly ignored filenames
      if (ALLOWED_EXT.has(ext) && !ignoreFiles.has(entry.name)) {
        results.push(fullPath);
      }
    }
  }

  return results;
}

function askQuestion(query) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise(resolve => {
    rl.question(query, answer => {
      rl.close();
      resolve(answer);
    });
  });
}

(async () => {
  try {
    // Ask the user whether to ignore specific filenames
    const ans = (await askQuestion('Ignore file names? (y/n): '))
      .trim()
      .toLowerCase();

    // Build a set of filenames to ignore
    let ignoreFiles = new Set();
    if (ans === 'y' || ans === 'yes') {
      const list = await askQuestion(
        'Enter file names to ignore, separated by commas (e.g. dhkm.js, djksm.js): '
      );
      list
        .split(',')
        .map(name => name.trim())
        .filter(name => name.length > 0)
        .forEach(name => ignoreFiles.add(name));
      console.log(`Ignoring files: ${[...ignoreFiles].join(', ')}`);
    }

    // Determine base directory
    const baseDir = process.argv[2]
      ? path.resolve(process.argv[2])
      : __dirname;
    console.log(`Scanning folder: ${baseDir}`);

    // Collect and filter files
    const files = await collectFiles(baseDir, ignoreFiles);

    if (files.length === 0) {
      console.log('No files to merge.');
      process.exit(0);
    }

    // Read and merge contents
    let merged = '';
    for (let filePath of files) {
      const content = await fs.readFile(filePath, 'utf8');
      const rel = path
        .relative(baseDir, filePath)
        .split(path.sep)
        .join('/');
      merged += `${rel}\n${content}\n\n`;
    }

    // Write out merged.txt
    const outPath = path.join(baseDir, 'merged.txt');
    await fs.writeFile(outPath, merged, 'utf8');
    console.log(`âœ… Merged ${files.length} files into ${outPath}`);
  } catch (err) {
    console.error('Error:', err);
    process.exit(1);
  }
})();


src/app.ts
// backend/src/app.ts
import express, { Application } from 'express';
import cors from 'cors';
import path from 'path';
import helmet from 'helmet'; // Security middleware
import rateLimit from 'express-rate-limit'; // Rate limiting
import hpp from 'hpp'; // HTTP Parameter Pollution protection
import config from './config/default';
import authRoutes from './routes/auth.routes';
import onboardingRoutes from './routes/onboarding.routes';
import verificationRoutes from './routes/verification.routes';
import adminRoutes from './routes/admin.routes';
import commerceRoutes from './modules/commerce'; // New commerce routes
import { notFoundHandler, errorHandler } from './middlewares/error.middleware';

const app: Application = express();

// Security middleware
app.use(helmet());

// HTTP Parameter Pollution protection
app.use(hpp());

// Global rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 200, // limit each IP to 200 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});

app.use(limiter);

// More aggressive rate limiting for auth routes
const authLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10, // limit each IP to 10 requests per windowMs
  message: 'Too many authentication attempts, please try again later'
});

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// CORS configuration
app.use(
  cors({
    origin: config.frontendUrl,
    credentials: true,
  })
);

// API Routes with rate limits where needed
app.use('/api/auth', authLimiter, authRoutes);
app.use('/api/onboarding', onboardingRoutes);
app.use('/api/verification', verificationRoutes);
app.use('/api/admin', adminRoutes);

// Add new commerce routes
app.use('/api', commerceRoutes);

// In production, serve the frontend
if (process.env.NODE_ENV === 'production') {
  // Serve static files
  app.use(express.static(path.join(__dirname, '../../frontend/out')));

  // All other requests go to the React app
  app.get('*', (req, res) => {
    res.sendFile(path.resolve(__dirname, '../../frontend/out/index.html'));
  });
}

// Error handling middleware - use 'as any' to bypass TypeScript strict checking
// This is an acceptable workaround for Express middleware in TypeScript
app.use(notFoundHandler as any);
app.use(errorHandler as any);

export default app;

src/config/db.ts
import mongoose from 'mongoose';
import config from './default';
import logger from '../utils/logger';

const connectDB = async (): Promise<void> => {
  try {
    await mongoose.connect(config.mongoURI);
    logger.info('MongoDB connected successfully');
  } catch (error) {
    logger.error('MongoDB connection failed:', error);
    process.exit(1);
  }
};

export default connectDB;

src/config/default.ts
import dotenv from 'dotenv';
dotenv.config();

export default {
  port: process.env.PORT || 5000,
  mongoURI: process.env.MONGODB_URI || 'mongodb://localhost:27017/riskpay',
  jwtSecret: process.env.JWT_SECRET || 'your_jwt_secret_key_change_this_in_production',
  nodeEnv: process.env.NODE_ENV || 'development',
  defaultTimezone: process.env.DEFAULT_TIMEZONE || 'America/Sao_Paulo',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:3000',
  emailFrom: process.env.EMAIL_FROM || 'noreply@riskpay.com',
  holdDays: 14, // Default days to hold funds
  supportedCountries: ['US', 'BR'], // Available countries for merchants
};

src/controllers/admin.balance.controller.ts
// src/controllers/admin.balance.controller.ts
// Controller for admin operations on merchant balances, FX rates and financial settings

import { Request, Response } from 'express';
import { successResponse, errorResponse } from '../utils/response';
import BalanceService from '../services/balance.service';
import FxService from '../services/fx.service';
import BalanceModel from '../models/balance.model';
import MerchantModel from '../models/merchant.model';
import SettingModel from '../models/settings.model';
import FxRateModel from '../models/fx-rate.model';
import NotificationService from '../services/notification.service';
import UserModel from '../models/user.model';
import logger from '../utils/logger';

// @desc    Admin - Get merchant balance
// @route   GET /api/admin/finance/:merchantId
// @access  Admin only
export const adminGetMerchantBalance = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    const { merchantId } = req.params;

    // Get balance
    const balance = await BalanceService.getBalance(merchantId);

    // Get merchant
    const merchant = await MerchantModel.findById(merchantId);

    if (!merchant) {
      return errorResponse(res, 'Merchant not found', null, 404);
    }

    // Get user for contact info
    const user = await UserModel.findOne({ merchantId });

    return successResponse(res, 'Merchant balance retrieved successfully', {
      balance: {
        reserve: balance.reserve,
        available: balance.available,
        pending: balance.pending,
        totalBalance: balance.totalBalance,
        currency: balance.dashboardCurrency,
      },
      merchant: {
        businessName: merchant.businessName,
        country: merchant.country,
        dashboardCurrency: merchant.dashboardCurrency,
        payoutCurrency: merchant.payoutCurrency,
        holdDays: merchant.holdDays,
        fxSpreadPercent: merchant.fxSpreadPercent,
      },
      user: user
        ? {
            email: user.email,
            idVerified: user.idCheckStatus === 'verified',
          }
        : null,
    });
  } catch (error) {
    logger.error('Admin - Error retrieving merchant balance:', error);
    return errorResponse(
      res,
      'An error occurred while retrieving merchant balance',
      null,
      500
    );
  }
};

// @desc    Admin - Adjust merchant balance
// @route   PATCH /api/admin/finance/:merchantId/balance
// @access  Admin only with full access
export const adminAdjustMerchantBalance = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    const { merchantId } = req.params;
    const { reserve, available, pending, reason } = req.body;

    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(
        res,
        'This operation requires admin access key',
        null,
        403
      );
    }

    // Validate input
    if (
      (reserve === undefined &&
        available === undefined &&
        pending === undefined) ||
      !reason
    ) {
      return errorResponse(
        res,
        'At least one balance adjustment and reason are required',
        null,
        400
      );
    }

    // Get merchant
    const merchant = await MerchantModel.findById(merchantId);

    if (!merchant) {
      return errorResponse(res, 'Merchant not found', null, 404);
    }

    // Create adjustments object
    const adjustments: any = {};

    if (reserve !== undefined) {
      adjustments.reserve = parseFloat(reserve);
    }

    if (available !== undefined) {
      adjustments.available = parseFloat(available);
    }

    if (pending !== undefined) {
      adjustments.pending = parseFloat(pending);
    }

    // Adjust balance
    const updatedBalance = await BalanceService.adminAdjustBalance(
      merchantId,
      adjustments,
      reason,
      req.adminUser.username
    );

    // Find user to notify
    const user = await UserModel.findOne({ merchantId });

    if (user) {
      // Prepare notification message
      let adjustmentText = '';

      if (reserve !== undefined) {
        adjustmentText += `Reserve: ${
          reserve > 0 ? '+' : ''
        }${reserve} ${updatedBalance.dashboardCurrency}. `;
      }

      if (available !== undefined) {
        adjustmentText += `Available: ${
          available > 0 ? '+' : ''
        }${available} ${updatedBalance.dashboardCurrency}. `;
      }

      if (pending !== undefined) {
        adjustmentText += `Pending: ${
          pending > 0 ? '+' : ''
        }${pending} ${updatedBalance.dashboardCurrency}. `;
      }

      // Create notification for the merchant
      await NotificationService.createNotification(
        user._id as string,
        'finance',
        'Balance Adjusted by Administrator',
        `Your account balance has been adjusted by an administrator. ${adjustmentText}Reason: ${reason}`,
        {
          adjustments,
          reason,
          adjustedBy: req.adminUser.username,
          timestamp: new Date(),
        }
      );
    }

    return successResponse(
      res,
      'Merchant balance adjusted successfully',
      {
        balance: {
          reserve: updatedBalance.reserve,
          available: updatedBalance.available,
          pending: updatedBalance.pending,
          totalBalance: updatedBalance.totalBalance,
          currency: updatedBalance.dashboardCurrency,
        },
        adjustments,
        reason,
      }
    );
  } catch (error) {
    logger.error('Admin - Error adjusting merchant balance:', error);
    return errorResponse(
      res,
      'An error occurred while adjusting merchant balance',
      null,
      500
    );
  }
};

// @desc    Admin - Change merchant currency settings
// @route   PATCH /api/admin/finance/:merchantId/currency
// @access  Admin only with full access
export const adminChangeMerchantCurrency = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    const { merchantId } = req.params;
    const { dashboardCurrency, payoutCurrency, fxSpreadPercent } = req.body;

    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(
        res,
        'This operation requires admin access key',
        null,
        403
      );
    }

    // Validate input
    if (
      !dashboardCurrency &&
      !payoutCurrency &&
      fxSpreadPercent === undefined
    ) {
      return errorResponse(
        res,
        'At least one currency setting must be provided',
        null,
        400
      );
    }

    // Get merchant
    const merchant = await MerchantModel.findById(merchantId);

    if (!merchant) {
      return errorResponse(res, 'Merchant not found', null, 404);
    }

    // Prepare updates
    const updates: any = {};
    const oldValues: any = {
      dashboardCurrency: merchant.dashboardCurrency,
      payoutCurrency: merchant.payoutCurrency,
      fxSpreadPercent: merchant.fxSpreadPercent,
    };

    if (dashboardCurrency) {
      // Validate currency
      if (!['USD', 'BRL'].includes(dashboardCurrency)) {
        return errorResponse(
          res,
          'Invalid dashboard currency. Must be USD or BRL.',
          null,
          400
        );
      }

      updates.dashboardCurrency = dashboardCurrency;
    }

    if (payoutCurrency) {
      // Validate currency
      if (!['USD', 'BRL'].includes(payoutCurrency)) {
        return errorResponse(
          res,
          'Invalid payout currency. Must be USD or BRL.',
          null,
          400
        );
      }

      updates.payoutCurrency = payoutCurrency;
    }

    if (fxSpreadPercent !== undefined) {
      // Validate spread
      if (
        isNaN(parseFloat(fxSpreadPercent)) ||
        parseFloat(fxSpreadPercent) < 0 ||
        parseFloat(fxSpreadPercent) > 10
      ) {
        return errorResponse(
          res,
          'FX spread percentage must be a number between 0 and 10',
          null,
          400
        );
      }

      updates.fxSpreadPercent = parseFloat(fxSpreadPercent);
    }

    // Update merchant
    const updatedMerchant = await MerchantModel.findByIdAndUpdate(
      merchantId,
      updates,
      { new: true }
    );

    // If dashboard currency changed, also update balance
    if (
      dashboardCurrency &&
      dashboardCurrency !== oldValues.dashboardCurrency
    ) {
      await BalanceModel.findOneAndUpdate(
        { merchantId },
        { dashboardCurrency }
      );
    }

    // Find user to notify
    const user = await UserModel.findOne({ merchantId });

    if (user) {
      // Create notification for the merchant
      await NotificationService.createNotification(
        user._id as string,
        'finance',
        'Currency Settings Updated',
        'Your account currency settings have been updated by an administrator.',
        {
          oldValues,
          newValues: updates,
          updatedBy: req.adminUser.username,
          timestamp: new Date(),
        }
      );
    }

    return successResponse(res, 'Merchant currency settings updated successfully', {
      merchant: {
        dashboardCurrency: updatedMerchant?.dashboardCurrency,
        payoutCurrency: updatedMerchant?.payoutCurrency,
        fxSpreadPercent: updatedMerchant?.fxSpreadPercent,
      },
      updated: Object.keys(updates),
    });
  } catch (error) {
    logger.error('Admin - Error changing merchant currency settings:', error);
    return errorResponse(
      res,
      'An error occurred while changing merchant currency settings',
      null,
      500
    );
  }
};

// @desc    Admin - Get current FX rates
// @route   GET /api/admin/finance/fx-rates
// @access  Admin only
export const adminGetFxRates = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    // Get current rates from database
    const rates = await FxRateModel.find({ effectiveTo: null }).sort({
      baseCurrency: 1,
      quoteCurrency: 1,
    });

    // Get default spread setting
    const defaultSpread = await (SettingModel as any).getByKey(
      'fxSpreadPercentDefault'
    );

    return successResponse(res, 'FX rates retrieved successfully', {
      rates,
      defaultSpread,
      timestamp: new Date(),
    });
  } catch (error) {
    logger.error('Admin - Error retrieving FX rates:', error);
    return errorResponse(
      res,
      'An error occurred while retrieving FX rates',
      null,
      500
    );
  }
};

// @desc    Admin - Update FX settings
// @route   PATCH /api/admin/settings/fx
// @access  Admin only with full access
export const adminUpdateFxSettings = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    const { defaultSpread, autoFxUpdate } = req.body;

    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(
        res,
        'This operation requires admin access key',
        null,
        403
      );
    }

    // Validate input
    if (defaultSpread === undefined && autoFxUpdate === undefined) {
      return errorResponse(
        res,
        'At least one setting must be provided',
        null,
        400
      );
    }

    const updates: string[] = [];

    if (defaultSpread !== undefined) {
      if (
        isNaN(parseFloat(defaultSpread)) ||
        parseFloat(defaultSpread) < 0 ||
        parseFloat(defaultSpread) > 10
      ) {
        return errorResponse(
          res,
          'Default FX spread percentage must be a number between 0 and 10',
          null,
          400
        );
      }

      await (SettingModel as any).setByKey(
        'fxSpreadPercentDefault',
        parseFloat(defaultSpread),
        req.adminUser.username
      );
      updates.push('defaultSpread');
    }

    if (autoFxUpdate !== undefined) {
      await (SettingModel as any).setByKey(
        'autoFxUpdate',
        Boolean(autoFxUpdate),
        req.adminUser.username
      );
      updates.push('autoFxUpdate');
    }

    const currentSettings = {
      defaultSpread: await (SettingModel as any).getByKey(
        'fxSpreadPercentDefault'
      ),
      autoFxUpdate: await (SettingModel as any).getByKey('autoFxUpdate'),
    };

    return successResponse(res, 'FX settings updated successfully', {
      settings: currentSettings,
      updated: updates,
    });
  } catch (error) {
    logger.error('Admin - Error updating FX settings:', error);
    return errorResponse(
      res,
      'An error occurred while updating FX settings',
      null,
      500
    );
  }
};

// @desc    Admin - Force update FX rates (manual snapshot)
// @route   POST /api/admin/finance/fx-rates/update
// @access  Admin only with full access
export const adminForceUpdateFxRates = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    const { baseCurrency, quoteCurrency, rate } = req.body;

    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(
        res,
        'This operation requires admin access key',
        null,
        403
      );
    }

    // Validate input
    if (!baseCurrency || !quoteCurrency || rate === undefined) {
      return errorResponse(
        res,
        'Base currency, quote currency and rate are required',
        null,
        400
      );
    }

    const numericRate = parseFloat(rate);
    if (isNaN(numericRate) || numericRate <= 0) {
      return errorResponse(res, 'Rate must be a positive number', null, 400);
    }

    // Snapshot the provided rate
    await FxService.takeRateSnapshot(
      baseCurrency,
      quoteCurrency,
      numericRate
    );

    return successResponse(res, 'FX rate updated successfully', {
      baseCurrency,
      quoteCurrency,
      rate: numericRate,
      updatedAt: new Date(),
      updatedBy: req.adminUser.username,
    });
  } catch (error) {
    logger.error('Admin - Error updating FX rates:', error);
    return errorResponse(
      res,
      'An error occurred while updating FX rates',
      null,
      500
    );
  }
};

// @desc    Admin - Get merchant transactions
// @route   GET /api/admin/finance/:merchantId/transactions
// @access  Admin only
export const adminGetMerchantTransactions = async (
  req: Request,
  res: Response
): Promise<Response> => {
  try {
    const { merchantId } = req.params;
    const { page, limit, status, fromDate, toDate, sortBy, sortOrder } =
      req.query;

    // Verify merchant exists
    const merchant = await MerchantModel.findById(merchantId);

    if (!merchant) {
      return errorResponse(res, 'Merchant not found', null, 404);
    }

    // Build query placeholder
    const query: any = { merchantId };

    if (status) {
      query.status = status;
    }
    if (fromDate || toDate) {
      query.createdAt = {};
      if (fromDate) {
        query.createdAt.$gte = new Date(fromDate as string);
      }
      if (toDate) {
        query.createdAt.$lte = new Date(toDate as string);
      }
    }

    const pageNum = page ? parseInt(page as string) : 1;
    const limitNum = limit ? parseInt(limit as string) : 20;
    const skip = (pageNum - 1) * limitNum;

    const sort: any = {};
    const sortField = (sortBy as string) || 'createdAt';
    const sortDirection = sortOrder === 'asc' ? 1 : -1;
    sort[sortField] = sortDirection;

    // Placeholder empty result
    const transactions: any[] = [];
    const total = 0;

    return successResponse(
      res,
      'Merchant transactions retrieved successfully',
      {
        merchant: {
          id: merchantId,
          businessName: merchant.businessName,
          country: merchant.country,
          dashboardCurrency: merchant.dashboardCurrency,
        },
        transactions,
        total,
        page: pageNum,
        limit: limitNum,
        pages: Math.ceil(total / limitNum),
      }
    );
  } catch (error) {
    logger.error('Admin - Error retrieving merchant transactions:', error);
    return errorResponse(
      res,
      'An error occurred while retrieving merchant transactions',
      null,
      500
    );
  }
};


src/controllers/admin.controller.ts
// backend/src/controllers/admin.controller.ts
// Admin dashboard controller for document verification management

import { Request, Response } from 'express';
import fs from 'fs';
import path from 'path';
import UserModel from '../models/user.model';
import MerchantModel from '../models/merchant.model';
import VerificationModel from '../models/verification.model';
import PaymentRateModel from '../models/payment-rate.model';
import AddressModel from '../models/address.model';
import { successResponse, errorResponse } from '../utils/response';
import logger from '../utils/logger';
import config from '../config/default';
import { maskSensitiveData, decryptData } from './verification.controller';

// @desc    Admin login
// @route   POST /api/admin/login
// @access  Public
export const adminLogin = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { username, password, accessKey } = req.body;

    // Validate admin credentials from environment variables
    const adminUsers = (process.env.ADMIN_USERNAMES || '').split(',');
    const adminPasswords = (process.env.ADMIN_ACCESS_KEYS || '').split(',');

    // Find matching username and password pair
    const userIndex = adminUsers.findIndex(user => user.trim() === username);

    if (userIndex === -1 || adminPasswords[userIndex]?.trim() !== password) {
      return errorResponse(res, 'Invalid admin credentials', null, 401);
    }

    // Check if access key is provided and valid
    const hasFullAccess = accessKey === process.env.ADMIN_ACCESS_KEY;

    // Generate admin token with access flag
    const adminToken = Buffer.from(`${username}:${Date.now()}:${hasFullAccess}`).toString('base64');

    return successResponse(res, 'Admin login successful', {
      adminToken,
      hasFullAccess
    });
  } catch (error) {
    logger.error('Admin login error:', error);
    return errorResponse(res, 'An error occurred during admin login', null, 500);
  }
};

// @desc    Get pending verifications list
// @route   GET /api/admin/verifications/pending
// @access  Admin only
export const getPendingVerifications = async (req: Request, res: Response): Promise<Response> => {
  try {
    // Find all verifications with pending status
    const pendingVerifications = await VerificationModel.find({ status: 'pending' })
      .populate('userId', 'email')
      .populate('merchantId', 'businessName country');

    // Clone and sanitize the data to ensure no sensitive information is revealed
    const sanitizedVerifications = pendingVerifications.map(verification => {
      const verificationObj = verification.toObject();

      // Remove sensitive document numbers from the response
      if (verificationObj.businessDocument && verificationObj.businessDocument.number) {
        verificationObj.businessDocument.number = '[Hidden]';
      }

      if (verificationObj.personalDocument && verificationObj.personalDocument.number) {
        verificationObj.personalDocument.number = '[Hidden]';
      }

      return verificationObj;
    });

    return successResponse(res, 'Pending verifications retrieved', { pendingVerifications: sanitizedVerifications });
  } catch (error) {
    logger.error('Error fetching pending verifications:', error);
    return errorResponse(res, 'An error occurred while fetching verifications', null, 500);
  }
};

// @desc    Get rejected verifications list
// @route   GET /api/admin/verifications/rejected
// @access  Admin only
export const getRejectedVerifications = async (req: Request, res: Response): Promise<Response> => {
  try {
    // Find all verifications with rejected status
    const rejectedVerifications = await VerificationModel.find({ status: 'rejected' })
      .populate('userId', 'email')
      .populate('merchantId', 'businessName country');

    return successResponse(res, 'Rejected verifications retrieved', { rejectedVerifications });
  } catch (error) {
    logger.error('Error fetching rejected verifications:', error);
    return errorResponse(res, 'An error occurred while fetching verifications', null, 500);
  }
};

// @desc    Get verification details
// @route   GET /api/admin/verifications/:id
// @access  Admin only
export const getVerificationDetails = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;

    // Find verification by ID
    const verification = await VerificationModel.findById(id)
      .populate('userId', 'email idCheckStatus')
      .populate('merchantId', 'businessName country');

    if (!verification) {
      return errorResponse(res, 'Verification not found', null, 404);
    }

    // Clone verification object to avoid modifying the original stored data
    const resultVerification = JSON.parse(JSON.stringify(verification));

    // Handle document numbers based on access permissions
    if (!req.adminUser || !req.adminUser.hasFullAccess) {
      console.log("No access key - hiding sensitive document numbers");

      // Completely hide document numbers
      if (resultVerification.businessDocument) {
        resultVerification.businessDocument.number = "[Hidden - Access Key Required]";
      }

      if (resultVerification.personalDocument) {
        resultVerification.personalDocument.number = "[Hidden - Access Key Required]";
      }

      if (resultVerification.bankDetails) {
        resultVerification.bankDetails.accountNumber = "[Hidden - Access Key Required]";
        if (resultVerification.bankDetails.routingNumber) {
          resultVerification.bankDetails.routingNumber = "[Hidden - Access Key Required]";
        }
      }
    } else {
      // When access key is provided, decrypt sensitive data if necessary
      console.log("Access key provided - showing sensitive data");

      if (resultVerification.businessDocument?.number) {
        try {
          // Check if the number is in encrypted format
          if (resultVerification.businessDocument.number.includes(':')) {
            resultVerification.businessDocument.number = decryptData(resultVerification.businessDocument.number);
          }
        } catch (error) {
          console.error('Error decrypting business document number:', error);
          resultVerification.businessDocument.number = '[Decryption error]';
        }
      }

      if (resultVerification.personalDocument?.number) {
        try {
          // Check if the number is in encrypted format
          if (resultVerification.personalDocument.number.includes(':')) {
            resultVerification.personalDocument.number = decryptData(resultVerification.personalDocument.number);
          }
        } catch (error) {
          console.error('Error decrypting personal document number:', error);
          resultVerification.personalDocument.number = '[Decryption error]';
        }
      }
    }

    return successResponse(res, 'Verification details retrieved', {
      verification: resultVerification,
      hasFullAccess: req.adminUser?.hasFullAccess || false
    });
  } catch (error) {
    logger.error('Error fetching verification details:', error);
    return errorResponse(res, 'An error occurred while fetching verification details', null, 500);
  }
};

// @desc    Update verification status
// @route   POST /api/admin/verifications/:id/update
// @access  Admin only
export const updateVerificationStatus = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const {
      overallStatus,
      businessDocStatus,
      personalDocStatus,
      bankDetailsStatus,
      rejectionNote,
      businessDocRejectionReason,
      personalDocRejectionReason,
      bankDetailsRejectionReason,
    } = req.body;

    // No document key check anymore - we rely on admin token with hasFullAccess

    // Find verification by ID
    const verification = await VerificationModel.findById(id);

    if (!verification) {
      return errorResponse(res, 'Verification not found', null, 404);
    }

    // Store the overall rejection note if provided
    if (rejectionNote) {
      verification.rejectionNote = rejectionNote;
    }

    // Update business document status
    if (businessDocStatus) {
      if (
        verification.businessDocument.status !== businessDocStatus ||
        (businessDocStatus === 'rejected' && businessDocRejectionReason)
      ) {
        verification.businessDocument.status = businessDocStatus;

        if (businessDocStatus === 'rejected' && businessDocRejectionReason) {
          verification.businessDocument.rejectionReason = businessDocRejectionReason;
        } else if (businessDocStatus === 'verified') {
          verification.businessDocument.rejectionReason = undefined;
        }
      }
    }

    // Update personal document status
    if (personalDocStatus) {
      if (
        verification.personalDocument.status !== personalDocStatus ||
        (personalDocStatus === 'rejected' && personalDocRejectionReason)
      ) {
        verification.personalDocument.status = personalDocStatus;

        if (personalDocStatus === 'rejected' && personalDocRejectionReason) {
          verification.personalDocument.rejectionReason = personalDocRejectionReason;
        } else if (personalDocStatus === 'verified') {
          verification.personalDocument.rejectionReason = undefined;
        }
      }
    }

    // Update bank details status
    if (bankDetailsStatus) {
      if (
        verification.bankDetails.status !== bankDetailsStatus ||
        (bankDetailsStatus === 'rejected' && bankDetailsRejectionReason)
      ) {
        verification.bankDetails.status = bankDetailsStatus;

        if (bankDetailsStatus === 'rejected' && bankDetailsRejectionReason) {
          verification.bankDetails.rejectionReason = bankDetailsRejectionReason;
        } else if (bankDetailsStatus === 'verified') {
          verification.bankDetails.rejectionReason = undefined;
        }
      }
    }

    // Update overall status if provided
    if (overallStatus) {
      verification.status = overallStatus;

      if (overallStatus === 'verified') {
        verification.verifiedAt = new Date();
      }

      const user = await UserModel.findById(verification.userId);
      if (user) {
        user.idCheckStatus = overallStatus;
        await user.save();
      }
    } else {
      const allDocumentsVerified =
        verification.businessDocument.status === 'verified' &&
        verification.personalDocument.status === 'verified' &&
        verification.bankDetails.status === 'verified';

      const anyDocumentRejected =
        verification.businessDocument.status === 'rejected' ||
        verification.personalDocument.status === 'rejected' ||
        verification.bankDetails.status === 'rejected';

      if (allDocumentsVerified) {
        verification.status = 'verified';
        verification.verifiedAt = new Date();

        const user = await UserModel.findById(verification.userId);
        if (user) {
          user.idCheckStatus = 'verified';
          await user.save();
        }
      } else if (anyDocumentRejected) {
        verification.status = 'rejected';

        const user = await UserModel.findById(verification.userId);
        if (user) {
          user.idCheckStatus = 'rejected';
          await user.save();
        }
      }
    }

    await verification.save();

    return successResponse(res, 'Verification status updated successfully', { verification });
  } catch (error) {
    logger.error('Error updating verification status:', error);
    return errorResponse(res, 'An error occurred while updating verification', null, 500);
  }
};

// @desc    Get document file
// @route   GET /api/admin/documents/:type/:id/:field
// @access  Admin only (full access)
export const getDocumentFile = async (req: Request, res: Response): Promise<any> => {
  try {
    const { type, id, field } = req.params;

    console.log('Document request received for:', { type, id, field });

    // Check if admin is authenticated and has full access
    // The authenticateAdmin middleware already verified the token in req.query.adminToken
    if (!req.adminUser || !req.adminUser.hasFullAccess) {
      return errorResponse(res, 'Access key required to view documents', null, 403);
    }

    // Find verification by ID
    const verification = await VerificationModel.findById(id);

    if (!verification) {
      return errorResponse(res, 'Verification not found', null, 404);
    }

    let filePath = '';

    // Determine file path based on type and field
    if (type === 'business') {
      filePath = verification.businessDocument.documentImage || '';
    } else if (type === 'personal') {
      if (field === 'front') {
        filePath = verification.personalDocument.frontImage || '';
      } else if (field === 'back') {
        filePath = verification.personalDocument.backImage || '';
      } else if (field === 'selfie') {
        filePath = verification.personalDocument.selfieImage || '';
      }
    } else if (type === 'bank') {
      filePath = verification.bankDetails.statementDocument || '';
    }

    if (!filePath) {
      return errorResponse(res, 'Document not found', null, 404);
    }

    // Resolve absolute file path
    const absFilePath = path.resolve(filePath);

    // Check if file exists
    if (!fs.existsSync(absFilePath)) {
      return errorResponse(res, 'Document file not found', null, 404);
    }

    // Set appropriate content type based on file extension
    const fileExt = path.extname(filePath).toLowerCase();
    if (fileExt === '.pdf') {
      res.setHeader('Content-Type', 'application/pdf');
    } else if (fileExt === '.jpg' || fileExt === '.jpeg') {
      res.setHeader('Content-Type', 'image/jpeg');
    } else if (fileExt === '.png') {
      res.setHeader('Content-Type', 'image/png');
    } else if (fileExt === '.gif') {
      res.setHeader('Content-Type', 'image/gif');
    }

    // Send file
    return res.sendFile(absFilePath);
  } catch (error) {
    console.error('Error fetching document file:', error);
    return errorResponse(res, 'An error occurred while fetching document', null, 500);
  }
};

// @desc    Get payment rates
// @route   GET /api/admin/payment-rates
// @access  Admin only
export const getPaymentRates = async (req: Request, res: Response): Promise<Response> => {
  try {
    const paymentRates = await PaymentRateModel.find().sort({ countries: 1, receiptDays: 1 });

    return successResponse(res, 'Payment rates retrieved', { paymentRates });
  } catch (error) {
    logger.error('Error fetching payment rates:', error);
    return errorResponse(res, 'An error occurred while fetching payment rates', null, 500);
  }
};

// @desc    Get payment rate by ID
// @route   GET /api/admin/payment-rates/:id
// @access  Admin only
export const getPaymentRateById = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;

    const paymentRate = await PaymentRateModel.findById(id);

    if (!paymentRate) {
      return errorResponse(res, 'Payment rate not found', null, 404);
    }

    return successResponse(res, 'Payment rate retrieved', { paymentRate });
  } catch (error) {
    logger.error('Error fetching payment rate:', error);
    return errorResponse(res, 'An error occurred while fetching payment rate', null, 500);
  }
};

// @desc    Create or update payment rate
// @route   POST /api/admin/payment-rates
// @access  Admin only
export const updatePaymentRate = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const { countries, receiptDays, rateType, rateValue, currencies } = req.body;

    // Validate required fields
    if (!countries || !countries.length || !receiptDays || !rateType) {
      return errorResponse(res, 'Missing required fields', null, 400);
    }

    // Validate values based on rate type
    if (rateType === 'percentage' && rateValue === undefined) {
      return errorResponse(res, 'Rate value is required for percentage type', null, 400);
    }

    if (rateType === 'fixed' && (!currencies || (!currencies.USD && !currencies.BRL))) {
      return errorResponse(res, 'At least one currency rate is required for fixed type', null, 400);
    }

    // Prepare the rate object
    const rateData: any = {
      countries,
      receiptDays: parseInt(receiptDays),
      rateType,
    };

    // Set values based on rate type
    if (rateType === 'percentage') {
      rateData.rateValue = parseFloat(rateValue);
      rateData.currencies = { USD: undefined, BRL: undefined };
    } else {
      rateData.currencies = currencies;
      rateData.rateValue = undefined;
    }

    let paymentRate;

    if (id) {
      // Update existing rate
      paymentRate = await PaymentRateModel.findByIdAndUpdate(id, rateData, { new: true });
    } else {
      // Create new rate
      paymentRate = await PaymentRateModel.create(rateData);
    }

    if (!paymentRate) {
      return errorResponse(res, 'Failed to update payment rate', null, 500);
    }

    return successResponse(res, 'Payment rate updated successfully', { paymentRate });
  } catch (error) {
    logger.error('Error updating payment rate:', error);
    return errorResponse(res, 'An error occurred while updating payment rate', null, 500);
  }
};

// @desc    Delete payment rate
// @route   DELETE /api/admin/payment-rates/:id
// @access  Admin only
export const deletePaymentRate = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;

    // Find and delete rate
    const paymentRate = await PaymentRateModel.findByIdAndDelete(id);

    if (!paymentRate) {
      return errorResponse(res, 'Payment rate not found', null, 404);
    }

    return successResponse(res, 'Payment rate deleted successfully', null);
  } catch (error) {
    logger.error('Error deleting payment rate:', error);
    return errorResponse(res, 'An error occurred while deleting payment rate', null, 500);
  }
};

// @desc    Get users with filtering
// @route   GET /api/admin/users
// @access  Admin only
export const getUsers = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { status, search } = req.query;

    // Build the query
    let query: any = {};

    // Filter by status if provided
    if (status && status !== 'all') {
      if (status === 'verified' || status === 'pending' || status === 'rejected') {
        query.idCheckStatus = status;
      } else if (status === 'suspended' || status === 'blocked') {
        query.status = status;
      }
    }

    // Add search if provided
    if (search) {
      const searchRegex = new RegExp(search as string, 'i');
      query.$or = [{ email: searchRegex }];
    }

    // Fetch users with their merchant data
    const users = await UserModel.find(query)
      .populate('merchantId', 'businessName country')
      .sort({ createdAt: -1 });

    return successResponse(res, 'Users retrieved successfully', { users });
  } catch (error) {
    logger.error('Error fetching users:', error);
    return errorResponse(res, 'An error occurred while fetching users', null, 500);
  }
};

// @desc    Get user details
// @route   GET /api/admin/users/:id
// @access  Admin only
export const getUserDetails = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;

    // Find user by ID
    const user = await UserModel.findById(id).populate(
      'merchantId',
      'businessName country status sellingMethod integrationTypes',
    );

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    // Get verification data if exists
    const verification = await VerificationModel.findOne({ userId: id });

    return successResponse(res, 'User details retrieved', { user, verification });
  } catch (error) {
    logger.error('Error fetching user details:', error);
    return errorResponse(res, 'An error occurred while fetching user details', null, 500);
  }
};

// @desc    Activate user (unblock or unsuspend)
// @route   POST /api/admin/users/:id/activate
// @access  Admin only
export const activateUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // No document key check - we rely on admin token with hasFullAccess

    // Find user by ID
    const user = await UserModel.findById(id);

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    // Update user status
    user.status = 'active';
    user.suspendedUntil = undefined;
    await user.save();

    return successResponse(res, 'User activated successfully', { user });
  } catch (error) {
    logger.error('Error activating user:', error);
    return errorResponse(res, 'An error occurred while activating user', null, 500);
  }
};

// @desc    Suspend user
// @route   POST /api/admin/users/:id/suspend
// @access  Admin only
export const suspendUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const { suspendUntil } = req.body;

    // No document key check - we rely on admin token with hasFullAccess

    // Validate suspend until date
    if (!suspendUntil) {
      return errorResponse(res, 'Suspension end date is required', null, 400);
    }

    // Find user by ID
    const user = await UserModel.findById(id);

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    // Update user status
    user.status = 'suspended';
    user.suspendedUntil = new Date(suspendUntil);
    await user.save();

    return successResponse(res, 'User suspended successfully', { user });
  } catch (error) {
    logger.error('Error suspending user:', error);
    return errorResponse(res, 'An error occurred while suspending user', null, 500);
  }
};

// @desc    Block user
// @route   POST /api/admin/users/:id/block
// @access  Admin only
export const blockUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // No document key check - we rely on admin token with hasFullAccess

    // Find user by ID
    const user = await UserModel.findById(id);

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    // Update user status
    user.status = 'blocked';
    await user.save();

    return successResponse(res, 'User blocked successfully', { user });
  } catch (error) {
    logger.error('Error blocking user:', error);
    return errorResponse(res, 'An error occurred while blocking user', null, 500);
  }
};

// @desc    Request verification resubmission
// @route   POST /api/admin/users/:id/resubmit
// @access  Admin only
export const resubmitVerification = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // No document key check - we rely on admin token with hasFullAccess

    // Find user by ID
    const user = await UserModel.findById(id);

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    // Find and update verification document if exists
    const verification = await VerificationModel.findOne({ userId: id });
    if (verification) {
      // Set status of specific sections to rejected to request resubmission
      verification.status = 'pending';

      if (verification.businessDocument.status !== 'verified') {
        verification.businessDocument.status = 'rejected';
        verification.businessDocument.rejectionReason = 'Resubmission required by admin';
      }
      if (verification.personalDocument.status !== 'verified') {
        verification.personalDocument.status = 'rejected';
        verification.personalDocument.rejectionReason = 'Resubmission required by admin';
      }
      if (verification.bankDetails.status !== 'verified') {
        verification.bankDetails.status = 'rejected';
        verification.bankDetails.rejectionReason = 'Resubmission required by admin';
      }

      verification.rejectionNote = 'Please resubmit the marked verification documents as requested by administrator';

      await verification.save();

      user.idCheckStatus = 'pending';
      await user.save();
    } else {
      return errorResponse(res, 'No verification record found for this user', null, 404);
    }

    return successResponse(res, 'Verification resubmission requested successfully', {
      user,
      verification: {
        businessDocStatus: verification.businessDocument.status,
        personalDocStatus: verification.personalDocument.status,
        bankDetailsStatus: verification.bankDetails.status,
        overallStatus: verification.status,
      },
    });
  } catch (error) {
    logger.error('Error requesting verification resubmission:', error);
    return errorResponse(res, 'An error occurred while requesting verification resubmission', null, 500);
  }
};

// @desc    Unverify a user
// @route   POST /api/admin/users/:id/unverify
// @access  Admin only
export const unverifyUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // No document key check - we rely on admin token with hasFullAccess

    // Find the user
    const user = await UserModel.findById(id);

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    // Reset verification status
    user.idCheckStatus = undefined;
    await user.save();

    // Find verification document if exists
    const verification = await VerificationModel.findOne({ userId: id });
    if (verification) {
      verification.status = 'rejected';
      verification.businessDocument.status = 'rejected';
      verification.businessDocument.rejectionReason = 'Resubmission required by admin';
      verification.personalDocument.status = 'rejected';
      verification.personalDocument.rejectionReason = 'Resubmission required by admin';
      verification.bankDetails.status = 'rejected';
      verification.bankDetails.rejectionReason = 'Resubmission required by admin';
      verification.rejectionNote = 'All verification documents must be resubmitted as requested by administrator';

      await verification.save();
    }

    return successResponse(res, 'User verification status reset successfully', null);
  } catch (error) {
    logger.error('Error unverifying user:', error);
    return errorResponse(res, 'An error occurred while resetting verification status', null, 500);
  }
};

// @desc    Edit user information
// @route   POST /api/admin/users/:id/edit
// @access  Admin only
export const editUserInfo = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const { field, value } = req.body;
    
    // No document key check - we rely on admin token with hasFullAccess

    const user = await UserModel.findById(id);
    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    switch (field) {
      case 'email':
        const existingUser = await UserModel.findOne({ email: value, _id: { $ne: id } });
        if (existingUser) {
          return errorResponse(res, 'Email already in use by another account', null, 400);
        }
        user.email = value;
        break;

      case 'role':
        if (!['merchant', 'admin'].includes(value)) {
          return errorResponse(res, 'Invalid role value', null, 400);
        }
        user.role = value;
        break;

      case 'status':
        if (!['active', 'suspended', 'blocked'].includes(value)) {
          return errorResponse(res, 'Invalid status value', null, 400);
        }
        user.status = value;
        break;

      case 'suspendedUntil':
        if (user.status !== 'suspended') {
          return errorResponse(res, 'User must be suspended to set suspension end date', null, 400);
        }
        user.suspendedUntil = new Date(value);
        break;

      case 'idCheckStatus':
        if (!['', 'pending', 'verified', 'rejected'].includes(value)) {
          return errorResponse(res, 'Invalid verification status', null, 400);
        }
        user.idCheckStatus = value || undefined;
        break;

      case 'emailVerified':
        const isVerified = value === 'true';
        user.emailVerifiedAt = isVerified ? new Date() : undefined;
        break;

      case 'businessName':
        if (!user.merchantId) {
          return errorResponse(res, 'User does not have a merchant profile', null, 400);
        }
        const merchant = await MerchantModel.findById(user.merchantId);
        if (!merchant) {
          return errorResponse(res, 'Merchant profile not found', null, 404);
        }
        merchant.businessName = value;
        await merchant.save();
        break;

      case 'country':
        if (!user.merchantId) {
          return errorResponse(res, 'User does not have a merchant profile', null, 400);
        }
        if (!['US', 'BR'].includes(value)) {
          return errorResponse(res, 'Invalid country code. Supported countries are US and BR', null, 400);
        }
        const merchantForCountry = await MerchantModel.findById(user.merchantId);
        if (!merchantForCountry) {
          return errorResponse(res, 'Merchant profile not found', null, 404);
        }
        merchantForCountry.country = value as 'US' | 'BR';
        merchantForCountry.defaultCurrency = value === 'BR' ? 'BRL' : 'USD';
        await merchantForCountry.save();
        break;

      case 'sellingMethod':
        if (!user.merchantId) {
          return errorResponse(res, 'User does not have a merchant profile', null, 400);
        }
        if (!['hosted_store', 'integration'].includes(value)) {
          return errorResponse(res, 'Invalid selling method', null, 400);
        }
        const merchantForMethod = await MerchantModel.findById(user.merchantId);
        if (!merchantForMethod) {
          return errorResponse(res, 'Merchant profile not found', null, 404);
        }
        merchantForMethod.sellingMethod = value as 'hosted_store' | 'integration';
        await merchantForMethod.save();
        break;

      default:
        return errorResponse(res, `Cannot edit field "${field}"`, null, 400);
    }

    await user.save();

    return successResponse(res, `Successfully updated ${field}`, { field, value });
  } catch (error) {
    logger.error('Error editing user info:', error);
    return errorResponse(res, 'An error occurred while updating user information', null, 500);
  }
};

// @desc    Delete user account
// @route   POST /api/admin/users/:id/delete
// @access  Admin only
export const deleteUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // No document key check - we rely on admin token with hasFullAccess

    const user = await UserModel.findById(id);

    if (!user) {
      return errorResponse(res, 'User not found', null, 404);
    }

    if (user.merchantId) {
      await MerchantModel.findByIdAndDelete(user.merchantId);
      await AddressModel.deleteMany({ merchantId: user.merchantId });

      const verification = await VerificationModel.findOne({ merchantId: user.merchantId });
      if (verification) {
        const filesToDelete = [
          verification.businessDocument?.documentImage,
          verification.personalDocument?.frontImage,
          verification.personalDocument?.backImage,
          verification.personalDocument?.selfieImage,
          verification.bankDetails?.statementDocument,
        ].filter(Boolean);

        for (const filePath of filesToDelete) {
          if (filePath && fs.existsSync(filePath)) {
            try {
              fs.unlinkSync(filePath);
            } catch (err) {
              logger.error(`Error deleting file ${filePath}:`, err);
            }
          }
        }

        await VerificationModel.deleteOne({ _id: verification._id });
      }
    }

    await UserModel.findByIdAndDelete(id);

    return successResponse(res, 'User deleted successfully', null);
  } catch (error) {
    logger.error('Error deleting user:', error);
    return errorResponse(res, 'An error occurred while deleting user', null, 500);
  }
};


src/controllers/admin.product.controller.ts
// src/controllers/admin.product.controller.ts
// Controller for admin operations on products

import { Request, Response } from 'express';
import { successResponse, errorResponse } from '../utils/response';
import ProductService from '../services/product.service';
import NotificationService from '../services/notification.service';
import logger from '../utils/logger';
import UserModel from '../models/user.model';
import ProductModel from '../models/product.model';
import { PipelineStage } from 'mongoose';

// @desc    Admin - Get all products with advanced filtering
// @route   GET /api/admin/products
// @access  Admin only
export const adminGetProducts = async (req: Request, res: Response): Promise<Response> => {
  try {
    const {
      page,
      limit,
      status,
      type,
      currency,
      search,
      merchantId,
      sortBy,
      sortOrder,
      fromDate,
      toDate,
      priceMin,
      priceMax,
    } = req.query;
    
    // Query products with admin privileges
    const result = await ProductService.adminGetProducts({
      page: page ? parseInt(page as string) : undefined,
      limit: limit ? parseInt(limit as string) : undefined,
      status: status as any,
      type: type as any,
      currency: currency as string,
      search: search as string,
      merchantId: merchantId as string,
      sortBy: sortBy as string,
      sortOrder: sortOrder as any,
      fromDate: fromDate ? new Date(fromDate as string) : undefined,
      toDate: toDate ? new Date(toDate as string) : undefined,
      priceMin: priceMin ? parseFloat(priceMin as string) : undefined,
      priceMax: priceMax ? parseFloat(priceMax as string) : undefined,
    });
    
    return successResponse(res, 'Products retrieved successfully', result);
  } catch (error) {
    logger.error('Admin - Error retrieving products:', error);
    return errorResponse(res, 'An error occurred while retrieving products', null, 500);
  }
};

// @desc    Admin - Get a single product by ID
// @route   GET /api/admin/products/:id
// @access  Admin only
export const adminGetProductById = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // Get product
    const product = await ProductService.getProductById(id);
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    // Get merchant details for context
    const merchant = await UserModel.findOne({ merchantId: product.merchantId })
      .select('email _id')
      .populate('merchantId', 'businessName country');
    
    return successResponse(res, 'Product retrieved successfully', { 
      product,
      merchant: merchant || null 
    });
  } catch (error) {
    logger.error('Admin - Error retrieving product:', error);
    return errorResponse(res, 'An error occurred while retrieving product', null, 500);
  }
};

// @desc    Admin - Update a product
// @route   PUT /api/admin/products/:id
// @access  Admin only with full access
export const adminUpdateProduct = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(res, 'This operation requires admin access key', null, 403);
    }
    
    // Update product with admin privileges
    const product = await ProductService.adminUpdateProduct(
      id, 
      updates, 
      req.adminUser.username
    );
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    // If significant updates (e.g. price change, deactivation), notify the merchant
    if (updates.price !== undefined || updates.status === 'deactivated') {
      // Find the merchant (user) by merchantId
      const user = await UserModel.findOne({ merchantId: product.merchantId });
      
      if (user) {
        // Create notification for the merchant
        const message = updates.status === 'deactivated'
          ? `Your product "${product.title}" has been deactivated by an administrator.`
          : `Your product "${product.title}" has been updated by an administrator.`;
          
        await NotificationService.createNotification(
            user._id as string,
          'product',
          'Product Updated by Admin',
          message,
          { 
            productId: product._id,
            updatedBy: req.adminUser.username,
            changes: Object.keys(updates)
          }
        );
      }
    }
    
    return successResponse(res, 'Product updated successfully', { product });
  } catch (error) {
    logger.error('Admin - Error updating product:', error);
    return errorResponse(res, 'An error occurred while updating product', null, 500);
  }
};

// @desc    Admin - Delete a product (hard delete)
// @route   DELETE /api/admin/products/:id
// @access  Admin only with full access
export const adminDeleteProduct = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(res, 'This operation requires admin access key', null, 403);
    }
    
    // Verify product exists
    const product = await ProductService.getProductById(id);
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    // Hard delete (completely remove from database)
    await product.deleteOne();
    
    // Find the merchant (user) by merchantId
    const user = await UserModel.findOne({ merchantId: product.merchantId });
    
    if (user) {
      // Create notification for the merchant
      await NotificationService.createNotification(
        user._id as string,
        'product',
        'Product Deleted by Admin',
        `Your product "${product.title}" has been permanently deleted by an administrator.`,
        { 
            productId: (product._id as import('mongoose').Types.ObjectId).toString(),
          deletedBy: req.adminUser.username
        }
      );
    }
    
    return successResponse(res, 'Product permanently deleted', { productId: id });
  } catch (error) {
    logger.error('Admin - Error deleting product:', error);
    return errorResponse(res, 'An error occurred while deleting product', null, 500);
  }
};

// @desc    Admin - Force change product currency
// @route   PATCH /api/admin/products/:id/currency
// @access  Admin only with full access
export const adminChangeProductCurrency = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const { currency, newPrice } = req.body;
    
    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(res, 'This operation requires admin access key', null, 403);
    }
    
    // Validate required fields
    if (!currency) {
      return errorResponse(res, 'Currency is required', null, 400);
    }
    
    // Verify currency is valid
    const validCurrencies = ['USD', 'BRL', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY'];
    if (!validCurrencies.includes(currency.toUpperCase())) {
      return errorResponse(res, `Invalid currency. Supported currencies: ${validCurrencies.join(', ')}`, null, 400);
    }
    
    // Get product
    const product = await ProductService.getProductById(id);
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    // Update currency (and price if provided)
    const updates: any = { 
      currency: currency.toUpperCase() 
    };
    
    if (newPrice !== undefined) {
      updates.price = parseFloat(newPrice);
    }
    
    // Update product
    const updatedProduct = await ProductService.adminUpdateProduct(
      id,
      updates,
      req.adminUser.username
    );
    
    // Find the merchant (user) by merchantId and notify
    const user = await UserModel.findOne({ merchantId: product.merchantId });
    
    if (user) {
      await NotificationService.createNotification(
        user._id as string,
        'product',
        'Product Currency Changed',
        `The currency for your product "${product.title}" has been changed from ${product.currency} to ${currency.toUpperCase()} by an administrator.`,
        { 
          productId: product._id,
          oldCurrency: product.currency,
          newCurrency: currency.toUpperCase(),
          oldPrice: product.price,
          newPrice: updates.price || product.price
        }
      );
    }
    
    return successResponse(res, 'Product currency updated successfully', { product: updatedProduct });
  } catch (error) {
    logger.error('Admin - Error changing product currency:', error);
    return errorResponse(res, 'An error occurred while changing product currency', null, 500);
  }
};

// @desc    Admin - Get product stats
// @route   GET /api/admin/products/stats
// @access  Admin only
export const adminGetProductStats = async (req: Request, res: Response): Promise<Response> => {
  try {
    // Get high-level stats
    const totalActive = await ProductService.adminGetProducts({ status: 'active' }).then(r => r.total);
    const totalDeactivated = await ProductService.adminGetProducts({ status: 'deactivated' }).then(r => r.total);
    const totalDeleted = await ProductService.adminGetProducts({ status: 'deleted' }).then(r => r.total);
    
    // Get currency distribution
    const pipeline: PipelineStage[] = [
             {
               $group: {
                 _id: '$currency',
                 count: { $sum: 1 },
                 avgPrice: { $avg: '$price' }
               }
             },
             {
               // Use a literal 1 or -1 so TS recognizes it as valid Sort order
               $sort: { count: 1 }
             }
           ];
           const currencyStats = await ProductModel.aggregate(pipeline);
    
    // Get type distribution
    const typePipeline = [
      {
        $group: {
          _id: '$type',
          count: { $sum: 1 }
        }
      }
    ];
    
    const typeStats = await ProductModel.aggregate(typePipeline);
    
    return successResponse(res, 'Product statistics retrieved', {
      counts: {
        total: totalActive + totalDeactivated + totalDeleted,
        active: totalActive,
        deactivated: totalDeactivated,
        deleted: totalDeleted
      },
      currencies: currencyStats,
      types: typeStats
    });
  } catch (error) {
    logger.error('Admin - Error getting product stats:', error);
    return errorResponse(res, 'An error occurred while retrieving product statistics', null, 500);
  }
};

src/controllers/auth.controller.ts
import { Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import config from '../config/default';
import UserModel, { IUser } from '../models/user.model';
import MerchantModel from '../models/merchant.model';
import { successResponse, errorResponse } from '../utils/response';
import logger from '../utils/logger';

// Generate JWT token
const generateToken = (id: string): string => {
  return jwt.sign({ id }, config.jwtSecret, {
    expiresIn: '7d', // Token expires in 7 days
  });
};

// backend/src/controllers/auth.controller.ts 
// Update the register function:

// @desc    Register a new user (step 1 of onboarding)
// @route   POST /api/auth/register
// @access  Public
export const register = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
      return errorResponse(res, 'Please provide email and password', null, 400);
    }

    // Check if user already exists
    const existingUser = await UserModel.findOne({ email });
    if (existingUser) {
      return errorResponse(res, 'User already exists', null, 400);
    }

    // Create new user with onboardingStage 2 instead of 1
    // This means they've completed step 1 (signup) and should proceed to step 2 (business info)
    const user = await UserModel.create({
      email,
      password,
      role: 'merchant',
      onboardingStage: 2, // Changed from 1 to 2
      // Don't set idCheckStatus here to prevent premature verification display
    });

    // Generate token - Fix for TypeScript error by using as string
    const token = generateToken((user._id as unknown) as string);

    return successResponse(
      res,
      'User registered successfully',
      {
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          onboardingStage: user.onboardingStage,
          onboardingComplete: user.onboardingComplete,
        },
        token,
      },
      201
    );
  } catch (error) {
    logger.error('Registration error:', error);
    return errorResponse(res, 'Server error during registration', null, 500);
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
export const login = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
      return errorResponse(res, 'Please provide email and password', null, 400);
    }

    // Find user
    const user = await UserModel.findOne({ email });
    if (!user) {
      return errorResponse(res, 'Invalid credentials', null, 401);
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return errorResponse(res, 'Invalid credentials', null, 401);
    }

    // Get merchant data if user is a merchant
    let merchantData = null;
    if (user.role === 'merchant' && user.merchantId) {
      merchantData = await MerchantModel.findById(user.merchantId);
    }

    // Generate token - Fix for TypeScript error by using as string
    const token = generateToken((user._id as unknown) as string);

    return successResponse(res, 'Login successful', {
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        onboardingStage: user.onboardingStage,
        onboardingComplete: user.onboardingComplete,
        emailVerified: user.emailVerifiedAt ? true : false,
      },
      merchant: merchantData ? {
        id: merchantData._id,
        businessName: merchantData.businessName,
        country: merchantData.country,
        status: merchantData.status,
        sellingMethod: merchantData.sellingMethod,
        integrationTypes: merchantData.integrationTypes,
      } : null,
      token,
    });
  } catch (error) {
    logger.error('Login error:', error);
    return errorResponse(res, 'Server error during login', null, 500);
  }
};

// @desc    Get current user
// @route   GET /api/auth/me
// @access  Private
// src/controllers/auth.controller.ts - getCurrentUser function fix

// backend/src/controllers/auth.controller.ts - getCurrentUser function

export const getCurrentUser = async (req: Request, res: Response): Promise<Response> => {
  try {
    const user = req.user;

    // Get merchant data if user is a merchant
    let merchantData = null;
    if (user.role === 'merchant' && user.merchantId) {
      merchantData = await MerchantModel.findById(user.merchantId);
    }

    return successResponse(res, 'User data retrieved successfully', {
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        onboardingStage: user.onboardingStage,
        onboardingComplete: user.onboardingComplete,
        emailVerified: user.emailVerifiedAt ? true : false,
        // Keep ID verification completely separate from email verification
        idVerified: user.idCheckStatus === 'verified', 
        idCheckStatus: user.idCheckStatus, // Return the raw status
        timezone: user.timezone
      },
      merchant: merchantData ? {
        id: merchantData._id,
        businessName: merchantData.businessName,
        country: merchantData.country,
        status: merchantData.status,
        firstName: merchantData.firstName,
        lastName: merchantData.lastName,
        defaultCurrency: merchantData.defaultCurrency,
        sellingMethod: merchantData.sellingMethod,
        integrationTypes: merchantData.integrationTypes,
      } : null,
    });
  } catch (error) {
    logger.error('Get current user error:', error);
    return errorResponse(res, 'Server error while fetching user data', null, 500);
  }
};


// @desc    Verify email by token
// @route   GET /api/auth/verify-email/:token
// @access  Public
export const verifyEmail = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { token } = req.params;

    if (!token) {
      return errorResponse(res, 'No token provided', null, 400);
    }

    // Verify token - in a real app you might store these tokens in a DB
    // For now, we'll just decode the token and trust it
    const decoded = jwt.verify(token, config.jwtSecret) as any;
    
    // Find user by id
    const user = await UserModel.findById(decoded.id);
    
    if (!user) {
      return errorResponse(res, 'Invalid token', null, 400);
    }

    // Update user's email verification status
    user.emailVerifiedAt = new Date();
    await user.save();

    // For API calls, return a success response with verification details
    const wantsJson = (req.headers['accept'] || '').includes('application/json');
if (wantsJson) {
      return successResponse(res, 'Email verified successfully', {
        verified: true,
        email: user.email,
        redirectUrl: user.onboardingComplete ? '/merchant' : `/onboarding`
      });
    }

    // For browser requests, redirect to appropriate page based on onboarding status
    if (user.onboardingComplete) {
      res.redirect(`${config.frontendUrl}/merchant?verified=true`);
    } else {
      res.redirect(`${config.frontendUrl}/onboarding?verified=true`);
    }
    return res;
  } catch (error) {
    logger.error('Email verification error:', error);
    
    // For API calls, return an error response
    const wantsJson = (req.headers['accept'] || '').includes('application/json');
    if (wantsJson) {
      return errorResponse(res, 'Invalid or expired token', null, 400);
    }
    
    // For browser requests, redirect to the frontend with error
    res.redirect(`${config.frontendUrl}/onboarding?verified=false`);
    return res;
  }
};

// @desc    Send verification email
// @route   POST /api/auth/send-verification-email
// @access  Private
export const sendVerificationEmail = async (req: Request, res: Response): Promise<Response> => {
  try {
    const user = req.user;

    // Check if email is already verified
    if (user.emailVerifiedAt) {
      return errorResponse(res, 'Email already verified', null, 400);
    }

    // Generate token - Fix for TypeScript error by using as string
    const token = generateToken((user._id as unknown) as string);

    // Create verification URL
    // In a real app, you would send this via email
    // For now, we'll return it for demo purposes
// only return the token
return successResponse(res, 'Verification email sent', { 
  token,
  email: user.email,
  message: "Demo mode: Verification token returned in response."
});
  } catch (error) {
    logger.error('Send verification email error:', error);
    return errorResponse(res, 'Server error while sending verification email', null, 500);
  }
};

// @desc    Check email verification status
// @route   GET /api/auth/verification-status
// @access  Private
export const getVerificationStatus = async (req: Request, res: Response): Promise<Response> => {
  try {
    const user = req.user;
    
    return successResponse(res, 'Verification status retrieved', {
      emailVerified: user.emailVerifiedAt ? true : false,
      idVerified: user.idCheckStatus === 'verified',
      pendingIdVerification: user.idCheckStatus === 'pending',
      idRejected: user.idCheckStatus === 'rejected',
      onboardingComplete: user.onboardingComplete
    });
  } catch (error) {
    logger.error('Get verification status error:', error);
    return errorResponse(res, 'Server error while fetching verification status', null, 500);
  }
};

src/controllers/balance.controller.ts
// src/controllers/balance.controller.ts
// Controller for merchant balance operations and financial data

import { Request, Response } from 'express';
import { successResponse, errorResponse } from '../utils/response';
import BalanceService from '../services/balance.service';
import FxService from '../services/fx.service';
import MerchantModel from '../models/merchant.model';
import logger from '../utils/logger';

// @desc    Get merchant balance
// @route   GET /api/finance/balance
// @access  Private (merchants only)
export const getBalance = async (req: Request, res: Response): Promise<Response> => {
  try {
    const merchantId = req.user.merchantId;
    
    if (!merchantId) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }
    
    // Get balance
    const balance = await BalanceService.getBalance(merchantId);
    
    // Get merchant to get dashboardCurrency
    const merchant = await MerchantModel.findById(merchantId);
    
    return successResponse(res, 'Balance retrieved successfully', {
      balance: {
        reserve: balance.reserve,
        available: balance.available,
        pending: balance.pending,
        totalBalance: balance.totalBalance,
        currency: balance.dashboardCurrency
      },
      holdDays: merchant?.holdDays || 14
    });
  } catch (error) {
    logger.error('Error retrieving balance:', error);
    return errorResponse(res, 'An error occurred while retrieving balance', null, 500);
  }
};

// @desc    Get merchant transactions
// @route   GET /api/finance/transactions
// @access  Private (merchants only)
export const getTransactions = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { page, limit, status, fromDate, toDate, sortBy, sortOrder } = req.query;
    const merchantId = req.user.merchantId;
    
    if (!merchantId) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }
    
    // Build query for orders
    const query: any = { merchantId };
    
    // Add status filter if provided
    if (status) {
      query.status = status;
    }
    
    // Add date range filter if provided
    if (fromDate || toDate) {
      query.createdAt = {};
      
      if (fromDate) {
        query.createdAt.$gte = new Date(fromDate as string);
      }
      
      if (toDate) {
        query.createdAt.$lte = new Date(toDate as string);
      }
    }
    
    // Set up pagination
    const pageNum = page ? parseInt(page as string) : 1;
    const limitNum = limit ? parseInt(limit as string) : 10;
    const skip = (pageNum - 1) * limitNum;
    
    // Set up sorting
    const sort: any = {};
    const sortField = sortBy as string || 'createdAt';
    const sortDirection = sortOrder === 'asc' ? 1 : -1;
    sort[sortField] = sortDirection;
    
    // Query transactions (from orders collection)
    // This is just a placeholder - in a real implementation,
    // we would query the orders collection with proper population
    const transactions: any[] = [];
    const total = 0;
    
    // For now, return a placeholder response
    // In a real implementation, this would return actual transaction data
    return successResponse(res, 'Transactions retrieved successfully', {
      transactions,
      total,
      page: pageNum,
      limit: limitNum,
      pages: Math.ceil(total / limitNum)
    });
  } catch (error) {
    logger.error('Error retrieving transactions:', error);
    return errorResponse(res, 'An error occurred while retrieving transactions', null, 500);
  }
};

// @desc    Request a manual payout
// @route   POST /api/finance/payout
// @access  Private (merchants only)
export const requestPayout = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { amount, currency } = req.body;
    const merchantId = req.user.merchantId;
    
    if (!merchantId) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }
    
    // Validate input
    if (!amount || amount <= 0) {
      return errorResponse(res, 'Valid amount is required', null, 400);
    }
    
    // Get balance
    const balance = await BalanceService.getBalance(merchantId);
    
    // Check if merchant has sufficient funds
    if (balance.available < amount) {
      return errorResponse(res, 'Insufficient available balance', null, 400);
    }
    
    // Get merchant for currency settings
    const merchant = await MerchantModel.findById(merchantId);
    
    if (!merchant) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }
    
    // Determine payout currency (default to merchant's payout currency)
    const payoutCurrency = currency || merchant.payoutCurrency || merchant.dashboardCurrency;
    
    // Convert amount if currencies don't match
    let payoutAmount = amount;
    let conversionInfo = null;
    
    if (balance.dashboardCurrency !== payoutCurrency) {
      const conversion = await FxService.convertCurrency(
        amount,
        balance.dashboardCurrency,
        payoutCurrency,
        merchant.fxSpreadPercent
      );
      
      payoutAmount = conversion.convertedAmount;
      conversionInfo = {
        fromCurrency: balance.dashboardCurrency,
        toCurrency: payoutCurrency,
        exchangeRate: conversion.effectiveRate,
        originalAmount: amount
      };
    }
    
    // For this implementation, we'll deduct from available balance
    // but in a real system, this would create a payout record and handle it asynchronously
    const updatedBalance = await BalanceService.deductFromAvailable(
      merchantId,
      amount,
      'manual-payout-request'
    );
    
    // Return success with payout details
    return successResponse(res, 'Payout requested successfully', {
      payout: {
        amount: payoutAmount,
        currency: payoutCurrency,
        status: 'processing',
        requestedAt: new Date()
      },
      conversionInfo,
      updatedBalance: {
        available: updatedBalance.available,
        currency: updatedBalance.dashboardCurrency
      }
    });
  } catch (error) {
    logger.error('Error requesting payout:', error);
    return errorResponse(res, 'An error occurred while requesting payout', null, 500);
  }
};

// @desc    Get current exchange rates
// @route   GET /api/finance/rates
// @access  Private (merchants only)
export const getExchangeRates = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { base, quote } = req.query;
    
    // Validate input
    if (!base || !quote) {
      return errorResponse(res, 'Base and quote currencies are required', null, 400);
    }
    
    // Get exchange rate
    const rate = await FxService.getCurrentRate(base as string, quote as string);
    
    // Get merchant for FX spread
    const merchantId = req.user.merchantId;
    let spreadRate = null;
    
    if (merchantId) {
      const merchant = await MerchantModel.findById(merchantId);
      if (merchant) {
        // Apply merchant-specific spread if available
        spreadRate = await FxService.applySpread(rate, merchant.fxSpreadPercent);
      }
    }
    
    // If no merchant-specific spread, apply default spread
    if (spreadRate === null) {
      spreadRate = await FxService.applySpread(rate);
    }
    
    return successResponse(res, 'Exchange rates retrieved successfully', {
      base: (base as string).toUpperCase(),
      quote: (quote as string).toUpperCase(),
      rate,
      effectiveRate: spreadRate,
      timestamp: new Date()
    });
  } catch (error) {
    logger.error('Error retrieving exchange rates:', error);
    return errorResponse(res, 'An error occurred while retrieving exchange rates', null, 500);
  }
};

src/controllers/notification.controller.ts
// src/controllers/notification.controller.ts
// Controller for handling user notifications

import { Request, Response } from 'express';
import { successResponse, errorResponse } from '../utils/response';
import NotificationService from '../services/notification.service';
import logger from '../utils/logger';

// @desc    Get user notifications
// @route   GET /api/notifications
// @access  Private
export const getUserNotifications = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { page, limit, unreadOnly, type } = req.query;
    
    // Query notifications
    const result = await NotificationService.getUserNotifications(
      req.user._id,
      {
        page: page ? parseInt(page as string) : undefined,
        limit: limit ? parseInt(limit as string) : undefined,
        unreadOnly: unreadOnly === 'true',
        type: type as any,
      }
    );
    
    return successResponse(res, 'Notifications retrieved successfully', result);
  } catch (error) {
    logger.error('Error retrieving notifications:', error);
    return errorResponse(res, 'An error occurred while retrieving notifications', null, 500);
  }
};

// @desc    Mark notifications as read
// @route   POST /api/notifications/read
// @access  Private
export const markNotificationsAsRead = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { ids } = req.body;
    
    // Check if ids is an array
    if (!Array.isArray(ids) || ids.length === 0) {
      return errorResponse(res, 'Notification IDs must be provided as an array', null, 400);
    }
    
    // Mark notifications as read
    const count = await NotificationService.markAsRead(req.user._id, ids);
    
    return successResponse(res, `${count} notification(s) marked as read`, { count });
  } catch (error) {
    logger.error('Error marking notifications as read:', error);
    return errorResponse(res, 'An error occurred while marking notifications as read', null, 500);
  }
};

// @desc    Mark all notifications as read
// @route   POST /api/notifications/read-all
// @access  Private
export const markAllNotificationsAsRead = async (req: Request, res: Response): Promise<Response> => {
  try {
    // Mark all notifications as read
    const count = await NotificationService.markAllAsRead(req.user._id);
    
    return successResponse(res, `${count} notification(s) marked as read`, { count });
  } catch (error) {
    logger.error('Error marking all notifications as read:', error);
    return errorResponse(res, 'An error occurred while marking all notifications as read', null, 500);
  }
};

// @desc    Delete a notification
// @route   DELETE /api/notifications/:id
// @access  Private
export const deleteNotification = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // Delete notification
    const result = await NotificationService.deleteNotification(req.user._id, id);
    
    return successResponse(res, 'Notification deleted successfully', { deleted: result });
  } catch (error) {
    logger.error('Error deleting notification:', error);
    
    if ((error as Error).message.includes('not found')) {
      return errorResponse(res, 'Notification not found or does not belong to you', null, 404);
    }
    
    return errorResponse(res, 'An error occurred while deleting notification', null, 500);
  }
};

// @desc    Admin - Broadcast notification
// @route   POST /api/admin/notifications/broadcast
// @access  Admin only with full access
export const adminBroadcastNotification = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { type, title, body, role, country, userIds } = req.body;
    
    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(res, 'This operation requires admin access key', null, 403);
    }
    
    // Validate required fields
    if (!type || !title || !body) {
      return errorResponse(res, 'Type, title, and body are required', null, 400);
    }
    
    // At least one targeting option must be provided
    if (!role && !country && (!userIds || userIds.length === 0)) {
      return errorResponse(res, 'At least one targeting option (role, country, or userIds) must be provided', null, 400);
    }
    
    // Broadcast notification
    const count = await NotificationService.adminBroadcastNotification(
      type,
      title,
      body,
      {
        role,
        country,
        userIds,
      },
      req.adminUser.username
    );
    
    return successResponse(res, `Notification broadcast to ${count} users`, { count });
  } catch (error) {
    logger.error('Admin - Error broadcasting notification:', error);
    return errorResponse(res, 'An error occurred while broadcasting notification', null, 500);
  }
};

// @desc    Admin - Delete user notifications
// @route   DELETE /api/admin/notifications/user/:userId
// @access  Admin only with full access
export const adminDeleteUserNotifications = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { userId } = req.params;
    
    // Check for full access
    if (!req.adminUser?.hasFullAccess) {
      return errorResponse(res, 'This operation requires admin access key', null, 403);
    }
    
    // Delete user notifications
    const count = await NotificationService.adminDeleteUserNotifications(
      userId,
      req.adminUser.username
    );
    
    return successResponse(res, `${count} notification(s) deleted for user`, { count });
  } catch (error) {
    logger.error('Admin - Error deleting user notifications:', error);
    return errorResponse(res, 'An error occurred while deleting user notifications', null, 500);
  }
};

src/controllers/onboarding.controller.ts
import { Request, Response } from 'express';
import UserModel from '../models/user.model';
import MerchantModel from '../models/merchant.model';
import AddressModel from '../models/address.model';
import { successResponse, errorResponse } from '../utils/response';
import logger from '../utils/logger';

// @desc    Create or update business info (step 2 of onboarding)
// @route   POST /api/onboarding/business
// @access  Private
export const updateBusinessInfo = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { businessName, country, firstName, lastName } = req.body;
    const user = req.user;

    // Validate input
    if (!businessName || !country || !firstName || !lastName) {
      return errorResponse(res, 'Please provide all required fields', null, 400);
    }

    // Validate country
    if (!['US', 'BR'].includes(country)) {
      return errorResponse(res, 'Invalid country. Supported countries are US and BR', null, 400);
    }

    // Check if user already has a merchant profile
// -----------------------------------------------
// Create or update the merchant, then ALWAYS
// persist the user with merchantId + stage
// -----------------------------------------------
let merchant: any;

if (user.merchantId) {
  // Update existing merchant
  merchant = await MerchantModel.findByIdAndUpdate(
    user.merchantId,
    {
      businessName,
      country,
      firstName,
      lastName,
      defaultCurrency: country === 'BR' ? 'BRL' : 'USD',
    },
    { new: true }
  );
} else {
  // Create new merchant
  merchant = await MerchantModel.create({
    businessName,
    country,
    firstName,
    lastName,
    defaultCurrency: country === 'BR' ? 'BRL' : 'USD',
  });

  // Link the merchant to the user
  user.merchantId = merchant._id;
}

/* â”€â”€ ALWAYS push the user to at least stage 2 and save â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
if (user.onboardingStage < 2) {
  user.onboardingStage = 2;
}
await user.save();         // â† this was previously skipped for stage 2 users
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */


    // Check if merchant was created or updated successfully
    if (!merchant) {
      return errorResponse(res, 'Failed to create or update merchant profile', null, 500);
    }

    return successResponse(res, 'Business information updated successfully', {
      merchant: {
        id: merchant._id,
        businessName: merchant.businessName,
        country: merchant.country,
        firstName: merchant.firstName,
        lastName: merchant.lastName,
      },
      nextStep: 3,
    });
  } catch (error) {
    logger.error('Update business info error:', error);
    return errorResponse(res, 'Server error during business info update', null, 500);
  }
};

// @desc    Update address information (step 3 of onboarding)
// @route   POST /api/onboarding/address
// @access  Private
export const updateAddress = async (req: Request, res: Response): Promise<Response> => {
  try {
    const {
      line1,
      line2,
      city,
      state,
      postalCode,
      country,
      timezone,
      phone, // Added phone field
    } = req.body;
    const user = req.user;

    // Validate input
    if (!line1 || !city || !state || !postalCode || !country || !timezone) {
      return errorResponse(res, 'Please provide all required fields', null, 400);
    }

    // Validate country
    if (!['US', 'BR'].includes(country)) {
      return errorResponse(res, 'Invalid country. Supported countries are US and BR', null, 400);
    }

    // Validate phone format if provided
    if (phone) {
      let isValidPhone = false;
      
      if (country === 'US') {
        // US phone validation - 10 digits, optional formatting
        isValidPhone = /^(\+1)?[\s-]?\(?(\d{3})\)?[\s-]?(\d{3})[\s-]?(\d{4})$/.test(phone);
      } else if (country === 'BR') {
        // Brazil phone validation - supports both mobile (with 9) and landline formats
        isValidPhone = /^(\+55)?[\s-]?\(?(\d{2})\)?[\s-]?9?(\d{4})[\s-]?(\d{4})$/.test(phone);
      }
      
      if (!isValidPhone) {
        return errorResponse(res, 'Invalid phone number format for the selected country', null, 400);
      }
    }

    // Ensure user has a merchant profile
    if (!user.merchantId) {
      return errorResponse(res, 'Business information must be set up first', null, 400);
    }

    // Check if merchant already has a legal address
    const existingAddress = await AddressModel.findOne({
      merchantId: user.merchantId,
      type: 'legal',
    });

    let address = null;
    if (existingAddress) {
      // Update existing address
      address = await AddressModel.findByIdAndUpdate(
        existingAddress._id,
        {
          line1,
          line2,
          city,
          state,
          postalCode,
          country,
          timezone,
          phone, // Added phone field
        },
        { new: true }
      );
    } else {
      // Create new address
      address = await AddressModel.create({
        merchantId: user.merchantId,
        type: 'legal',
        line1,
        line2,
        city,
        state,
        postalCode,
        country,
        timezone,
        phone, // Added phone field
      });
    }

    // Check if address was created or updated successfully
    if (!address) {
      return errorResponse(res, 'Failed to create or update address information', null, 500);
    }

    // Update user's timezone and onboarding stage
    user.timezone = timezone;
    if (user.onboardingStage <= 2) {
      user.onboardingStage = 3;
    }
    await user.save();

    return successResponse(res, 'Address information updated successfully', {
      address: {
        id: address._id,
        line1: address.line1,
        line2: address.line2,
        city: address.city,
        state: address.state,
        postalCode: address.postalCode,
        country: address.country,
        timezone: address.timezone,
        phone: address.phone, // Added phone field in response
      },
      nextStep: 4,
    });
  } catch (error) {
    logger.error('Update address error:', error);
    return errorResponse(res, 'Server error during address update', null, 500);
  }
};

// @desc    Update selling method (step 4 of onboarding)
// @route   POST /api/onboarding/selling-method
// @access  Private
export const updateSellingMethod = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { sellingMethod, integrationTypes } = req.body;
    const user = req.user;

    // Validate input
    if (!sellingMethod) {
      return errorResponse(res, 'Please provide a selling method', null, 400);
    }

    // Validate selling method
    if (!['hosted_store', 'integration'].includes(sellingMethod)) {
      return errorResponse(res, 'Invalid selling method', null, 400);
    }

    // Validate integration types if selling method is integration
    if (sellingMethod === 'integration' && (!integrationTypes || integrationTypes.length === 0)) {
      return errorResponse(res, 'Please provide at least one integration type', null, 400);
    }

    // Ensure user has a merchant profile
    if (!user.merchantId) {
      return errorResponse(res, 'Business information must be set up first', null, 400);
    }

    // Update merchant's selling method
    const merchant = await MerchantModel.findByIdAndUpdate(
      user.merchantId,
      {
        sellingMethod,
        integrationTypes: sellingMethod === 'integration' ? integrationTypes : [],
      },
      { new: true }
    );

    // Check if merchant was updated successfully
    if (!merchant) {
      return errorResponse(res, 'Failed to update selling method', null, 500);
    }

    // Complete onboarding
    user.onboardingStage = 4;
    user.onboardingComplete = true;
    await user.save();

    return successResponse(res, 'Selling method updated and onboarding completed', {
      merchant: {
        id: merchant._id,
        businessName: merchant.businessName,
        sellingMethod: merchant.sellingMethod,
        integrationTypes: merchant.integrationTypes,
      },
      onboardingComplete: true,
    });
  } catch (error) {
    logger.error('Update selling method error:', error);
    return errorResponse(res, 'Server error during selling method update', null, 500);
  }
};

// @desc    Get onboarding status and current step
// @route   GET /api/onboarding/status
// @access  Private
export const getOnboardingStatus = async (req: Request, res: Response): Promise<Response> => {
  try {
    const user = req.user;

    // Get merchant data if exists
    let merchantData = null;
    if (user.merchantId) {
      merchantData = await MerchantModel.findById(user.merchantId);
    }

    // Get address data if exists
    let addressData = null;
    if (user.merchantId) {
      addressData = await AddressModel.findOne({
        merchantId: user.merchantId,
        type: 'legal',
      });
    }

    return successResponse(res, 'Onboarding status retrieved successfully', {
      currentStage: user.onboardingStage,
      isComplete: user.onboardingComplete,
      emailVerified: user.emailVerifiedAt ? true : false,
      idVerified: user.idCheckStatus === 'verified',
      merchant: merchantData,
      address: addressData,
      nextStep: user.onboardingComplete ? null : user.onboardingStage + 1,
    });
  } catch (error) {
    logger.error('Get onboarding status error:', error);
    return errorResponse(res, 'Server error while fetching onboarding status', null, 500);
  }
};

src/controllers/product.controller.ts
// src/controllers/product.controller.ts
// Controller for product CRUD operations with verification checks

import { Request, Response } from 'express';
import { successResponse, errorResponse } from '../utils/response';
import ProductService from '../services/product.service';
import NotificationService from '../services/notification.service';
import logger from '../utils/logger';

// @desc    Create a new product
// @route   POST /api/products
// @access  Private (merchants only, verified)
export const createProduct = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { title, description, price, currency, type, digital, physical, variants, images } = req.body;
    
    // Check if all required fields are present
    if (!title || !description || !price || !currency || !type) {
      return errorResponse(res, 'Missing required fields', null, 400);
    }
    
    // Validate specific fields based on product type
    if (type === 'digital' && (!digital || !digital.fileUrl)) {
      return errorResponse(res, 'File URL is required for digital products', null, 400);
    }
    
    // Create product
    const product = await ProductService.createProduct(req.user._id, {
      title,
      description,
      price: parseFloat(price),
      currency: currency.toUpperCase(),
      type,
      digital,
      physical,
      variants,
      images: images || [],
    });
    
    // Create notification for the merchant
    await NotificationService.createNotification(
      req.user._id,
      'product',
      'Product Created',
      `Your product "${title}" has been created successfully.`,
      { productId: product._id }
    );
    
    return successResponse(res, 'Product created successfully', { product }, 201);
  } catch (error) {
    logger.error('Error creating product:', error);
    
    // Check for specific error cases
    if ((error as Error).message.includes('User is not eligible')) {
      return errorResponse(res, 'Complete email and ID verification before creating products', null, 403);
    }
    
    return errorResponse(res, 'An error occurred while creating product', (error as Error).message, 500);
  }
};

// @desc    Get all merchant's products
// @route   GET /api/products
// @access  Private (merchants only)
export const getMerchantProducts = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { page, limit, status, type, currency, search, sortBy, sortOrder } = req.query;
    
    // Get merchant ID from user
    const merchantId = req.user.merchantId;
    
    if (!merchantId) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }
    
    // Query products
    const result = await ProductService.getMerchantProducts(merchantId, {
      page: page ? parseInt(page as string) : undefined,
      limit: limit ? parseInt(limit as string) : undefined,
      status: status as any,
      type: type as any,
      currency: currency as string,
      search: search as string,
      sortBy: sortBy as string,
      sortOrder: sortOrder as any,
    });
    
    return successResponse(res, 'Products retrieved successfully', result);
  } catch (error) {
    logger.error('Error retrieving products:', error);
    return errorResponse(res, 'An error occurred while retrieving products', null, 500);
  }
};

// @desc    Get a single product by ID
// @route   GET /api/products/:id
// @access  Private (merchants only)
export const getProductById = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // Get product
    const product = await ProductService.getProductById(id);
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    // Check ownership
    if (product.merchantId.toString() !== req.user.merchantId?.toString()) {
      return errorResponse(res, 'You do not have permission to view this product', null, 403);
    }
    
    return successResponse(res, 'Product retrieved successfully', { product });
  } catch (error) {
    logger.error('Error retrieving product:', error);
    return errorResponse(res, 'An error occurred while retrieving product', null, 500);
  }
};

// @desc    Update a product
// @route   PUT /api/products/:id
// @access  Private (merchants only, verified)
export const updateProduct = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    // Update product
    const product = await ProductService.updateProduct(id, req.user._id, updates);
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    return successResponse(res, 'Product updated successfully', { product });
  } catch (error) {
    logger.error('Error updating product:', error);
    
    // Check for specific error cases
    if ((error as Error).message.includes('User is not eligible')) {
      return errorResponse(res, 'Complete email and ID verification before updating products', null, 403);
    }
    
    if ((error as Error).message.includes('permission')) {
      return errorResponse(res, 'You do not have permission to modify this product', null, 403);
    }
    
    return errorResponse(res, 'An error occurred while updating product', null, 500);
  }
};

// @desc    Delete a product (soft delete)
// @route   DELETE /api/products/:id
// @access  Private (merchants only)
export const deleteProduct = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // Delete product
    const product = await ProductService.deleteProduct(id, req.user._id);
    
    if (!product) {
      return errorResponse(res, 'Product not found', null, 404);
    }
    
    return successResponse(res, 'Product deleted successfully', { productId: id });
  } catch (error) {
    logger.error('Error deleting product:', error);
    
    if ((error as Error).message.includes('permission')) {
      return errorResponse(res, 'You do not have permission to delete this product', null, 403);
    }
    
    return errorResponse(res, 'An error occurred while deleting product', null, 500);
  }
};

// @desc    Get a public product (for checkout/public view)
// @route   GET /api/products/public/:id
// @access  Public
export const getPublicProduct = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { id } = req.params;
    
    // Get public product details
    const product = await ProductService.getPublicProductDetails(id);
    
    if (!product) {
      return errorResponse(res, 'Product not found or not active', null, 404);
    }
    
    return successResponse(res, 'Product details retrieved', { product });
  } catch (error) {
    logger.error('Error retrieving public product:', error);
    return errorResponse(res, 'An error occurred while retrieving product details', null, 500);
  }
};

src/controllers/verification.controller.ts
// backend/src/controllers/verification.controller.ts
// Handles merchant identity verification submission and status checks

import { Request, Response } from 'express';
import fs from 'fs';
import path from 'path';
import multer from 'multer';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto'; // For encryption
import UserModel from '../models/user.model';
import MerchantModel from '../models/merchant.model';
import VerificationModel, { IVerification } from '../models/verification.model';
import PaymentRateModel, { IPaymentRate } from '../models/payment-rate.model';
import { successResponse, errorResponse } from '../utils/response';
import logger from '../utils/logger';
import config from '../config/default';

// Configure multer for document uploads
const storage = multer.diskStorage({
  destination: (req: Express.Request, file: Express.Multer.File, callback: (error: Error | null, destination: string) => void) => {
    const uploadDir = path.join(__dirname, '../../uploads/verification');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    callback(null, uploadDir);
  },
  filename: (req: Express.Request, file: Express.Multer.File, callback: (error: Error | null, filename: string) => void) => {
    const uniquePrefix = uuidv4();
    callback(null, `${uniquePrefix}-${file.originalname}`);
  }
});

const fileFilter = (req: Express.Request, file: Express.Multer.File, callback: multer.FileFilterCallback) => {
  // Accept only images and PDFs
  if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
    callback(null, true);
  } else {
    callback(new Error('Only images and PDF files are allowed'));
  }
};

export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB file size limit
  }
});

// Helper function to partially mask sensitive data for display
export function maskSensitiveData(data: string, isDocumentNumber: boolean = false): string {
  if (!data) return '';
  
  // If the data is already in an error format, return it as-is
  if (data.startsWith('[') && data.endsWith(']')) {
    return data;
  }
  
  // If data contains a colon, it might be encrypted - just mask it as is
  if (data.includes(':')) {
    if (isDocumentNumber) {
      if (data.length <= 4) {
        return 'â€¢â€¢â€¢â€¢';
      }
      return data.substring(0, 2) + 'â€¢'.repeat(data.length - 4) + data.substring(data.length - 2);
    } else {
      if (data.length <= 8) {
        return data;
      }
      return data.substring(0, 4) + 'â€¢'.repeat(data.length - 8) + data.substring(data.length - 4);
    }
  }

  // For document numbers: Keep first and last 2 characters, mask the rest
  if (isDocumentNumber) {
    if (data.length <= 4) {
      return 'â€¢â€¢â€¢â€¢';
    }
    return data.substring(0, 2) + 'â€¢'.repeat(data.length - 4) + data.substring(data.length - 2);
  } else {
    // For bank info: Keep first and last 4 digits visible
    if (data.length <= 8) {
      return data; // Too short to mask meaningfully
    }
    return data.substring(0, 4) + 'â€¢'.repeat(data.length - 8) + data.substring(data.length - 4);
  }
}

// Skip encryption/decryption for now - just store plain text with a prefix
// This is a temporary solution to avoid the encryption issues
export function encryptData(text: string): string {
  try {
    // For development/testing only - use plain text with prefix
    return "PLAIN:" + text;
  } catch (error) {
    logger.error('Encryption error:', error);
    // Return a placeholder in case of error
    return 'ENCRYPTION_ERROR';
  }
}

// Simplified decryption that just returns the plain text
export function decryptData(encryptedText: string): string {
  try {
    // Check for plain text format
    if (encryptedText.startsWith('PLAIN:')) {
      return encryptedText.substring(6); // Remove the 'PLAIN:' prefix
    }
    
    // For any other format, return a message indicating it's encrypted
    return "[Encrypted data - format incompatible]";
  } catch (error) {
    logger.error('Decryption error:', error);
    // Return a placeholder in case of error
    return '[Decryption Error]';
  }
}

// @desc    Get verification status and requirements
// @route   GET /api/verification/status
// @access  Private (merchants only)
export const getVerificationStatus = async (req: Request, res: Response): Promise<Response> => {
  try {
    const user = req.user;

    // Check if user has a merchant profile
    if (!user.merchantId) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }

    // Get verification data if it exists
    const verification = await VerificationModel.findOne({ userId: user._id });

    // Get merchant data
    const merchant = await MerchantModel.findById(user.merchantId);

    if (!merchant) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }

    // Get ALL payment rates for this country (system level configuration)
    let paymentRates: IPaymentRate[] = [];

    try {
      paymentRates = await PaymentRateModel.find({
        $or: [
          { countries: merchant.country },
          { country: merchant.country } // For backward compatibility
        ]
      });
    } catch (error) {
      logger.error('Error fetching payment rates:', error);
      // Continue even if payment rates fetch fails
    }

    return successResponse(res, 'Verification status retrieved', {
      status: user.idCheckStatus,
      verification,
      country: merchant.country,
      paymentRates,
      requirements: getCountryRequirements(merchant.country),
    });
  } catch (error) {
    logger.error('Error fetching verification status:', error);
    return errorResponse(res, 'An error occurred while fetching verification status', null, 500);
  }
};

// @desc    Submit verification documents and data
// @route   POST /api/verification/submit
// @access  Private (merchants only)
export const submitVerification = async (req: Request, res: Response): Promise<Response> => {
  try {
    const user = req.user;
    const {
      businessDocType,
      businessDocNumber,
      personalDocType,
      personalDocNumber,
      bankAccountName,
      bankAccountNumber,
      routingNumber,
      bankName,
      bankBranch,
      receiptTime,
      paymentMethods
    } = req.body;

    // Validate required fields
    if (!businessDocType || !businessDocNumber || !personalDocType || !personalDocNumber ||
        !bankAccountName || !bankAccountNumber || !bankName) {
      return errorResponse(res, 'Missing required fields', null, 400);
    }

    // Check if user has a merchant profile
    if (!user.merchantId) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }

    // Get merchant data
    const merchant = await MerchantModel.findById(user.merchantId);

    if (!merchant) {
      return errorResponse(res, 'Merchant profile not found', null, 404);
    }

    // Check if files are uploaded - ensure req.files is defined and has the correct type
    if (!req.files || typeof req.files !== 'object') {
      return errorResponse(res, 'Document files are required', null, 400);
    }

    const files = req.files as Record<string, Express.Multer.File[]>;

    // Process file paths - all variables declared as string | undefined
    let businessDocImage: string | undefined;
    let personalDocFront: string | undefined;
    let personalDocBack: string | undefined;
    let personalSelfie: string | undefined;
    let bankStatement: string | undefined;

    if (files.businessDocImage && files.businessDocImage.length > 0) {
      businessDocImage = files.businessDocImage[0].path;
    }

    if (files.personalDocFront && files.personalDocFront.length > 0) {
      personalDocFront = files.personalDocFront[0].path;
    }

    if (files.personalDocBack && files.personalDocBack.length > 0 && personalDocType !== 'passport') {
      personalDocBack = files.personalDocBack[0].path;
    }

    if (files.personalSelfie && files.personalSelfie.length > 0) {
      personalSelfie = files.personalSelfie[0].path;
    }

    if (files.bankStatement && files.bankStatement.length > 0) {
      bankStatement = files.bankStatement[0].path;
    }

    // Get payment rate based on country and receipt days (SYSTEM LEVEL CONFIGURATION)
    const parsedReceiptTime = parseInt(receiptTime);

    // First try to get the default rate for this country and receipt days
    let paymentRate = await PaymentRateModel.findOne({
      $or: [
        { countries: merchant.country, receiptDays: parsedReceiptTime, isDefault: true },
        { country: merchant.country, receiptDays: parsedReceiptTime, isDefault: true } // For backward compatibility
      ]
    });

    // If no default rate found, try to get any rate for this country and receipt days
    if (!paymentRate) {
      paymentRate = await PaymentRateModel.findOne({
        $or: [
          { countries: merchant.country, receiptDays: parsedReceiptTime },
          { country: merchant.country, receiptDays: parsedReceiptTime } // For backward compatibility
        ]
      });
    }

    // If still no rate found, use a fallback default value
    const defaultRateValue = parsedReceiptTime === 5 ? 9.0 : 7.5; // Higher rate for faster payout
    const defaultRateType = 'percentage' as 'percentage' | 'fixed' | 'both';
    const rateType = paymentRate?.rateType || defaultRateType;
    const rateValue = paymentRate?.rateValue || defaultRateValue;

    // Encrypt document numbers before storing
    console.log(`Encrypting document numbers: business: ${businessDocNumber.length} chars, personal: ${personalDocNumber.length} chars`);
    const encryptedBusinessDocNumber = encryptData(businessDocNumber);
    const encryptedPersonalDocNumber = encryptData(personalDocNumber);

    // Check if verification already exists
    let verification = await VerificationModel.findOne({ userId: user._id });

    if (verification) {
      // Update existing verification
      verification.status = 'pending';
      verification.updatedAt = new Date();

      // Only update business document if it was rejected or if new document was submitted
      if (verification.businessDocument.status === 'rejected' || files.businessDocImage) {
        verification.businessDocument = {
          type: businessDocType,
          number: encryptedBusinessDocNumber, // Store encrypted version
          documentImage: businessDocImage || verification.businessDocument.documentImage,
          status: 'pending',
        };
      }

      // Only update personal document if it was rejected or if new document was submitted
      if (verification.personalDocument.status === 'rejected' ||
          files.personalDocFront || files.personalDocBack || files.personalSelfie) {
        verification.personalDocument = {
          type: personalDocType,
          number: encryptedPersonalDocNumber, // Store encrypted version
          frontImage: personalDocFront || verification.personalDocument.frontImage,
          backImage: personalDocBack || verification.personalDocument.backImage,
          selfieImage: personalSelfie || verification.personalDocument.selfieImage,
          status: 'pending',
        };
      }

      // Only update bank details if they were rejected or if new statement was submitted
      if (verification.bankDetails.status === 'rejected' || files.bankStatement) {
        verification.bankDetails = {
          accountName: bankAccountName,
          accountNumber: bankAccountNumber,
          routingNumber: routingNumber || undefined,
          bankName: bankName,
          bankBranch: bankBranch || verification.bankDetails.bankBranch || '',
          statementDocument: bankStatement || (verification.bankDetails ? verification.bankDetails.statementDocument : undefined),
          status: 'pending',
        };
      }

      verification.paymentSettings = {
        receiptTime: parsedReceiptTime as 5 | 14,
        rateType: rateType as 'percentage' | 'fixed',
        rateValue: rateValue,
        methods: {
          creditCard: paymentMethods.includes('creditCard'),
          paypal: paymentMethods.includes('paypal'),
          wallets: paymentMethods.includes('wallets'),
          pix: paymentMethods.includes('pix'),
        },
      };
    } else {
      // Create new verification record
      verification = new VerificationModel({
        merchantId: user.merchantId,
        userId: user._id,
        status: 'pending',
        submittedAt: new Date(),
        businessDocument: {
          type: businessDocType,
          number: encryptedBusinessDocNumber, // Store encrypted version
          documentImage: businessDocImage,
          status: 'pending',
        },
        personalDocument: {
          type: personalDocType,
          number: encryptedPersonalDocNumber, // Store encrypted version
          frontImage: personalDocFront,
          backImage: personalDocBack,
          selfieImage: personalSelfie,
          status: 'pending',
        },
        bankDetails: {
          accountName: bankAccountName,
          accountNumber: bankAccountNumber,
          routingNumber: routingNumber || undefined,
          bankName: bankName,
          bankBranch: bankBranch || '',
          statementDocument: bankStatement,
          status: 'pending',
        },
        paymentSettings: {
          receiptTime: parsedReceiptTime as 5 | 14,
          rateType: rateType as 'percentage' | 'fixed',
          rateValue: rateValue,
          methods: {
            creditCard: paymentMethods.includes('creditCard'),
            paypal: paymentMethods.includes('paypal'),
            wallets: paymentMethods.includes('wallets'),
            pix: paymentMethods.includes('pix'),
          },
        },
      });
    }

    // Save verification record
    await verification.save();

    // Update user status to pending
    user.idCheckStatus = 'pending';
    await user.save();

    return successResponse(res, 'Verification submitted successfully', {
      status: 'pending',
      message: 'Your verification is being processed. We will notify you when it is complete.',
    });
  } catch (error) {
    logger.error('Error submitting verification:', error);
    return errorResponse(res, 'An error occurred while submitting verification', null, 500);
  }
};

// @desc    Get document preview
// @route   GET /api/verification/document-preview
// @access  Private (merchants only)
export const getDocumentPreview = async (req: Request, res: Response): Promise<any> => {
  try {
    const user = req.user;
    const { type, field } = req.query;

    // Find verification record
    const verification = await VerificationModel.findOne({ userId: user._id });

    if (!verification) {
      return errorResponse(res, 'Verification not found', null, 404);
    }

    // Initialize filePath as an empty string or undefined
    let filePath: string | undefined;

    // Determine file path based on type and field
    if (type === 'business') {
      filePath = verification.businessDocument.documentImage;
    } else if (type === 'personal') {
      if (field === 'front') {
        filePath = verification.personalDocument.frontImage;
      } else if (field === 'back') {
        filePath = verification.personalDocument.backImage;
      } else if (field === 'selfie') {
        filePath = verification.personalDocument.selfieImage;
      }
    } else if (type === 'bank') {
      filePath = verification.bankDetails.statementDocument;
    }

    if (!filePath) {
      return errorResponse(res, 'Document not found', null, 404);
    }

    // Resolve absolute file path
    const absFilePath = path.resolve(filePath);

    // Check if file exists
    if (!fs.existsSync(absFilePath)) {
      return errorResponse(res, 'Document file not found', null, 404);
    }

    // Set appropriate content type based on file extension
    const fileExt = path.extname(filePath).toLowerCase();
    if (fileExt === '.pdf') {
      res.setHeader('Content-Type', 'application/pdf');
    } else if (fileExt === '.jpg' || fileExt === '.jpeg') {
      res.setHeader('Content-Type', 'image/jpeg');
    } else if (fileExt === '.png') {
      res.setHeader('Content-Type', 'image/png');
    } else if (fileExt === '.gif') {
      res.setHeader('Content-Type', 'image/gif');
    }

    // Send file
    return res.sendFile(absFilePath);
  } catch (error) {
    logger.error('Error fetching document preview:', error);
    return errorResponse(res, 'An error occurred while fetching document preview', null, 500);
  }
};

// Helper function to get country-specific document requirements
const getCountryRequirements = (country: string) => {
  switch (country) {
    case 'US':
      return {
        businessDocTypes: [
          { value: 'ein', label: 'Employer Identification Number (EIN)' },
          { value: 'ssn', label: 'Social Security Number (SSN)' },
          { value: 'stateRegistration', label: 'State Registration Number' },
        ],
        personalDocTypes: [
          { value: 'nationalId', label: 'National ID' },
          { value: 'driversLicense', label: "Driver's License" },
          { value: 'passport', label: 'International Passport' },
        ],
        requiresRoutingNumber: true,
        requiresBankBranch: false,
      };
    case 'BR':
      return {
        businessDocTypes: [
          { value: 'cnpj', label: 'CNPJ' },
          { value: 'cpf', label: 'CPF' },
        ],
        personalDocTypes: [
          { value: 'nationalId', label: 'National ID' },
          { value: 'driversLicense', label: "Driver's License" },
          { value: 'passport', label: 'International Passport' },
        ],
        requiresRoutingNumber: false,
        requiresBankBranch: true,
      };
    default:
      // Default for other countries
      return {
        businessDocTypes: [
          { value: 'businessId', label: 'Business ID' },
          { value: 'taxId', label: 'Tax ID' },
        ],
        personalDocTypes: [
          { value: 'nationalId', label: 'National ID' },
          { value: 'driversLicense', label: "Driver's License" },
          { value: 'passport', label: 'International Passport' },
        ],
        requiresRoutingNumber: false,
        requiresBankBranch: false,
      };
  }
};


src/middlewares/admin.middleware.ts
// src/middlewares/admin.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { errorResponse } from '../utils/response';
import logger from '../utils/logger';

export const authenticateAdmin = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  try {
    // Get admin token from header OR query parameter
    const adminToken = req.header('X-Admin-Token') || req.query.adminToken as string;
    
    if (!adminToken) {
      return errorResponse(res, 'Admin authentication required', null, 401);
    }
    
    try {
      const decodedToken = Buffer.from(adminToken, 'base64').toString('utf-8');
      const tokenParts = decodedToken.split(':');
      
      const [username, timestamp, hasAccessKey] = tokenParts;
      
      // Validate admin username from environment variables
      const adminUsers = (process.env.ADMIN_USERNAMES || '').split(',');
      
      if (!adminUsers.some(u => u.trim() === username.trim())) {
        return errorResponse(res, 'Invalid admin credentials', null, 401);
      }
      
      // Add admin info to request
      req.adminUser = { 
        username,
        hasFullAccess: hasAccessKey === 'true'
      };
      
      next();
    } catch (error) {
      logger.error('Error decoding admin token.:', error);
      return errorResponse(res, 'Invalid admin token format', null, 401);
    }
  } catch (error) {
    logger.error('Admin authentication error:', error);
    return errorResponse(res, 'Admin authentication failed', null, 500);
  }
};

// Middleware to check for full access (for modification operations)
export const requireFullAccess = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  if (!req.adminUser || !req.adminUser.hasFullAccess) {
    return errorResponse(res, 'Access key required for this operation', null, 403);
  }
  next();
};

// Add to global Express namespace
declare global {
  namespace Express {
    interface Request {
      adminUser?: {
        username: string;
        hasFullAccess: boolean;
      };
    }
  }
}

src/middlewares/auth.middleware.ts
// backend/src/middlewares/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import config from '../config/default';
import { errorResponse } from '../utils/response';
import UserModel from '../models/user.model';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: any;
    }
  }
}

export const authenticate = async (req: Request, res: Response, next: NextFunction): Promise<any> => {
  // Get token from header
  const token = req.header('Authorization')?.replace('Bearer ', '');

  // Check if token exists
  if (!token) {
    return errorResponse(res, 'No token provided, authorization denied', null, 401);
  }

  try {
    // Verify token
    const decoded = jwt.verify(token, config.jwtSecret) as any;
    
    // Find user by id
    const user = await UserModel.findById(decoded.id).select('-password');
    
    if (!user) {
      return errorResponse(res, 'User not found', null, 401);
    }
    
    // Check if user is suspended or blocked
    if (user.status === 'suspended') {
      // Check if suspension period has ended
      if (user.suspendedUntil && new Date() > user.suspendedUntil) {
        // Automatically reactivate user
        user.status = 'active';
        user.suspendedUntil = undefined;
        await user.save();
      } else {
        return errorResponse(res, 'Your account is temporarily suspended', {
          suspendedUntil: user.suspendedUntil
        }, 403);
      }
    }
    
    if (user.status === 'blocked') {
      return errorResponse(res, 'Your account has been blocked. Please contact support for assistance.', null, 403);
    }
    
    // Add user to request
    req.user = user;
    
    next();
  } catch (error) {
    return errorResponse(res, 'Token is invalid', null, 401);
  }
};

export const requireMerchantRole = (req: Request, res: Response, next: NextFunction): Response | void => {
  if (req.user && req.user.role === 'merchant') {
    return next();
  }
  
  return errorResponse(res, 'Access denied, merchant role required', null, 403);
};

export const requireAdminRole = (req: Request, res: Response, next: NextFunction): Response | void => {
  if (req.user && req.user.role === 'admin') {
    return next();
  }
  
  return errorResponse(res, 'Access denied, admin role required', null, 403);
};

export const requireOnboardingComplete = (req: Request, res: Response, next: NextFunction): Response | void => {
  if (req.user && req.user.onboardingComplete) {
    return next();
  }
  
  return errorResponse(res, 'Onboarding process not completed', {
    redirectUrl: '/onboarding',
    currentStage: req.user.onboardingStage
  }, 403);
};

// New middleware to require email verification
export const requireEmailVerified = (req: Request, res: Response, next: NextFunction): Response | void => {
  if (req.user && req.user.emailVerifiedAt) {
    return next();
  }
  
  return errorResponse(res, 'Email verification required', {
    redirectUrl: '/verify-email'
  }, 403);
};

// New middleware to require ID verification
export const requireIdVerification = (req: Request, res: Response, next: NextFunction): Response | void => {
  if (req.user && req.user.idCheckStatus === 'verified') {
    return next();
  }
  
  return errorResponse(res, 'ID verification required', {
    redirectUrl: '/merchant/verify-identity',
    status: req.user.idCheckStatus
  }, 403);
};

src/middlewares/error.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { errorResponse } from '../utils/response';
import logger from '../utils/logger';

// NotFoundError handler - must have next parameter for Express to recognize it correctly
export const notFoundHandler = (req: Request, res: Response, next: NextFunction): Response => {
  return errorResponse(res, `Route not found - ${req.originalUrl}`, null, 404);
};

// Global error handler - must have all 4 parameters for Express to recognize it as an error handler
export const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction): Response => {
  logger.error('Global error caught:', err);
  
  // Check for MongoDB duplicate key error
  if ((err as any).code === 11000) {
    const field = Object.keys((err as any).keyValue)[0];
    return errorResponse(res, `${field} already exists`, null, 400);
  }

  // Check for validation errors
  if ((err as any).name === 'ValidationError') {
    const errors = Object.values((err as any).errors).map((err: any) => err.message);
    return errorResponse(res, 'Validation error', errors, 400);
  }

  // Default error response
  return errorResponse(
    res,
    process.env.NODE_ENV === 'production' ? 'Server Error' : err.message,
    process.env.NODE_ENV === 'production' ? null : err,
    500
  );
};

src/models/address.model.ts
// backend/src/models/address.model.ts
import mongoose, { Document, Schema, Types } from 'mongoose';

export interface IAddress extends Document {
  merchantId: Types.ObjectId;
  type: 'legal' | 'warehouse' | 'billing';
  line1: string;
  line2?: string;
  city: string;
  state: string;
  postalCode: string;
  country: 'US' | 'BR';
  timezone: string;
  phone?: string; // Added phone field
}

const AddressSchema = new Schema<IAddress>(
  {
    merchantId: {
      type: Schema.Types.ObjectId,
      ref: 'Merchant',
      required: true,
    },
    type: {
      type: String,
      enum: ['legal', 'warehouse', 'billing'],
      default: 'legal',
    },
    line1: {
      type: String,
      required: true,
    },
    line2: {
      type: String,
    },
    city: {
      type: String,
      required: true,
    },
    state: {
      type: String,
      required: true,
    },
    postalCode: {
      type: String,
      required: true,
    },
    country: {
      type: String,
      enum: ['US', 'BR'],
      required: true,
    },
    timezone: {
      type: String,
      required: true,
    },
    phone: {
      type: String,
      // Not required, but will be validated if provided
    },
  },
  {
    timestamps: true,
  }
);

export default mongoose.model<IAddress>('Address', AddressSchema);

src/models/balance.model.ts
// src/models/balance.model.ts
// Model for merchant balance tracking with separate buckets for reserve, available, and pending amounts

import mongoose, { Document, Schema, Types } from 'mongoose';

export interface IBalance extends Document {
  merchantId: Types.ObjectId;
  dashboardCurrency: 'USD' | 'BRL';
  reserve: number;       // Funds in reserve (held for potential chargebacks/refunds)
  available: number;     // Funds available for withdrawal
  pending: number;       // Funds pending (e.g., in processing)
  totalBalance: number;  // Virtual property for total amount
  updatedAt: Date;
  createdAt: Date;
}

const BalanceSchema = new Schema<IBalance>(
  {
    merchantId: {
      type: Schema.Types.ObjectId,
      ref: 'Merchant',
      required: true,
      unique: true,
    },
    dashboardCurrency: {
      type: String,
      enum: ['USD', 'BRL'],
      required: true,
    },
    reserve: {
      type: Number,
      default: 0,
      min: 0,
    },
    available: {
      type: Number,
      default: 0,
      min: 0,
    },
    pending: {
      type: Number,
      default: 0,
      min: 0,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual property to calculate total balance
BalanceSchema.virtual('totalBalance').get(function (this: IBalance) {
  return this.reserve + this.available + this.pending;
});

// Ensure all balance updates are correctly formatted to 2 decimal places
BalanceSchema.pre('save', function (next) {
  this.reserve = parseFloat(this.reserve.toFixed(2));
  this.available = parseFloat(this.available.toFixed(2));
  this.pending = parseFloat(this.pending.toFixed(2));
  next();
});



export default mongoose.model<IBalance>('Balance', BalanceSchema);

src/models/fx-rate.model.ts
// src/models/fx-rate.model.ts
// Model for storing currency exchange rate snapshots to ensure consistent rates

import mongoose, { Document, Schema } from 'mongoose';

export interface IFxRate extends Document {
  baseCurrency: string;       // Base currency (e.g., 'USD')
  quoteCurrency: string;      // Quote currency (e.g., 'BRL')
  rate: number;               // Exchange rate (e.g., 5.88 for USD to BRL)
  source: string;             // Source of the rate (e.g., 'external-api')
  fetchedAt: Date;            // When the rate was fetched
  effectiveFrom: Date;        // When the rate becomes effective
  effectiveTo?: Date;         // When the rate expires (null for current rate)
}

const FxRateSchema = new Schema<IFxRate>(
  {
    baseCurrency: {
      type: String,
      required: true,
      uppercase: true,
      trim: true,
    },
    quoteCurrency: {
      type: String,
      required: true,
      uppercase: true,
      trim: true,
    },
    rate: {
      type: Number,
      required: true,
      min: 0,
    },
    source: {
      type: String,
      required: true,
      trim: true,
    },
    fetchedAt: {
      type: Date,
      required: true,
      default: Date.now,
    },
    effectiveFrom: {
      type: Date,
      required: true,
      default: Date.now,
    },
    effectiveTo: {
      type: Date,
      default: null,
    },
  },
  {
    timestamps: true,
  }
);

// Create indexes for efficient queries
FxRateSchema.index({ baseCurrency: 1, quoteCurrency: 1, effectiveFrom: -1 });
FxRateSchema.index({ baseCurrency: 1, quoteCurrency: 1, effectiveTo: 1 });
FxRateSchema.index({ fetchedAt: -1 });

// Static method to get current exchange rate
FxRateSchema.statics.getCurrentRate = async function(baseCurrency: string, quoteCurrency: string): Promise<IFxRate | null> {
  return this.findOne({
    baseCurrency: baseCurrency.toUpperCase(),
    quoteCurrency: quoteCurrency.toUpperCase(),
    effectiveFrom: { $lte: new Date() },
    $or: [
      { effectiveTo: null },
      { effectiveTo: { $gt: new Date() } }
    ]
  }).sort({ effectiveFrom: -1 });
};

// Static method to get historical rate at a specific date
FxRateSchema.statics.getRateAtDate = async function(
  baseCurrency: string, 
  quoteCurrency: string,
  date: Date
): Promise<IFxRate | null> {
  return this.findOne({
    baseCurrency: baseCurrency.toUpperCase(),
    quoteCurrency: quoteCurrency.toUpperCase(),
    effectiveFrom: { $lte: date },
    $or: [
      { effectiveTo: null },
      { effectiveTo: { $gt: date } }
    ]
  }).sort({ effectiveFrom: -1 });
};

// Static method to snapshot current rates
FxRateSchema.statics.snapshotRate = async function(
  baseCurrency: string,
  quoteCurrency: string,
  rate: number,
  source: string
): Promise<IFxRate> {
  // First, mark any current active rates as expired
  await this.updateMany(
    {
      baseCurrency: baseCurrency.toUpperCase(),
      quoteCurrency: quoteCurrency.toUpperCase(),
      effectiveTo: null
    },
    {
      effectiveTo: new Date()
    }
  );

  // Then create a new current rate
  return this.create({
    baseCurrency: baseCurrency.toUpperCase(),
    quoteCurrency: quoteCurrency.toUpperCase(),
    rate,
    source,
    fetchedAt: new Date(),
    effectiveFrom: new Date(),
    effectiveTo: null
  });
};

export default mongoose.model<IFxRate>('FxRate', FxRateSchema);

src/models/merchant.model.ts
// src/models/merchant.model.ts
// Updated Merchant model with currency handling and payout preferences

import mongoose, { Document, Schema, Types } from 'mongoose';

export interface IMerchant extends Document {
  businessName: string;
  country: 'US' | 'BR';
  defaultCurrency: 'USD' | 'BRL';
  holdDays: number;
  payoutSchedule: 'manual' | 'weekly' | 'biweekly' | 'monthly';
  sellingMethod: 'hosted_store' | 'integration';
  integrationTypes?: string[];
  status: 'pending_verification' | 'active' | 'suspended';
  firstName?: string;
  lastName?: string;
  
  // Added fields for currency handling
  dashboardCurrency: 'USD' | 'BRL'; // Currency displayed on dashboard
  fxSpreadPercent: number;          // Merchant-specific FX spread percentage
  payoutCurrency?: 'USD' | 'BRL';   // Currency for payouts (defaults based on country)
  sellsInternationally: boolean;    // Whether merchant sells outside their country
}

const MerchantSchema = new Schema<IMerchant>(
  {
    businessName: {
      type: String,
      required: true,
      trim: true,
    },
    country: {
      type: String,
      enum: ['US', 'BR'],
      required: true,
    },
    defaultCurrency: {
      type: String,
      enum: ['USD', 'BRL'],
      required: true,
    },
    holdDays: {
      type: Number,
      default: 14,
      enum: [5, 14], // Only allow 5 or 14 days
    },
    payoutSchedule: {
      type: String,
      enum: ['manual', 'weekly', 'biweekly', 'monthly'],
      default: 'manual',
    },
    sellingMethod: {
      type: String,
      enum: ['hosted_store', 'integration'],
      default: 'hosted_store',
    },
    integrationTypes: [{
      type: String,
      enum: ['shopify', 'woocommerce', 'wordpress', 'custom'],
    }],
    status: {
      type: String,
      enum: ['pending_verification', 'active', 'suspended'],
      default: 'pending_verification',
    },
    firstName: {
      type: String,
      trim: true,
    },
    lastName: {
      type: String,
      trim: true,
    },
    
    // Added fields for currency handling
    dashboardCurrency: {
      type: String,
      enum: ['USD', 'BRL'],
      required: true,
    },
    fxSpreadPercent: {
      type: Number,
      default: null, // Uses global setting if null
      min: 0,
      max: 10, // Cap at 10% to prevent abuse
    },
    payoutCurrency: {
      type: String,
      enum: ['USD', 'BRL'],
    },
    sellsInternationally: {
      type: Boolean,
      default: false
    }
  },
  {
    timestamps: true,
  }
);

// Set default currency based on country
MerchantSchema.pre('save', function(next) {
  // Set defaultCurrency based on country if not already set
  if (this.isNew || this.isModified('country')) {
    this.defaultCurrency = this.country === 'BR' ? 'BRL' : 'USD';
    
    // Set dashboardCurrency based on country
    this.dashboardCurrency = this.country === 'BR' ? 'BRL' : 'USD';
    
    // Set default payoutCurrency based on country if not already set
    if (!this.payoutCurrency) {
      this.payoutCurrency = this.country === 'BR' ? 'BRL' : 'USD';
    }
  }
  
  next();
});

export default mongoose.model<IMerchant>('Merchant', MerchantSchema);

src/models/notification.model.ts
// src/models/notification.model.ts
// Model for user notifications with read/unread status tracking

import mongoose, { Document, Schema, Types } from 'mongoose';

export type NotificationType = 'finance' | 'product' | 'security' | 'system' | 'verification';

export interface INotification extends Document {
  userId: Types.ObjectId;
  type: NotificationType;
  title: string;
  body: string;
  unread: boolean;
  createdAt: Date;
  readAt?: Date;
  expiresAt?: Date;      // Optional expiration date
  metadata?: Record<string, any>; // Optional additional data
}

const NotificationSchema = new Schema<INotification>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    type: {
      type: String,
      enum: ['finance', 'product', 'security', 'system', 'verification'],
      required: true,
      index: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 150,
    },
    body: {
      type: String,
      required: true,
      trim: true,
      maxlength: 2000,
    },
    unread: {
      type: Boolean,
      default: true,
      index: true,
    },
    readAt: {
      type: Date,
      default: null,
    },
    expiresAt: {
      type: Date,
      default: null,
    },
    metadata: {
      type: Schema.Types.Mixed,
      default: {},
    },
  },
  {
    timestamps: true,
  }
);

// Compound index for faster querying of unread notifications per user
NotificationSchema.index({ userId: 1, unread: 1 });

// Index for expiring notifications
NotificationSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Static method to create a notification
NotificationSchema.statics.createNotification = async function(
  userId: Types.ObjectId, 
  type: NotificationType, 
  title: string, 
  body: string, 
  metadata: Record<string, any> = {},
  expiresAt?: Date
): Promise<INotification> {
  return this.create({
    userId,
    type,
    title,
    body,
    unread: true,
    metadata,
    expiresAt
  });
};

// Static method to mark notifications as read
NotificationSchema.statics.markAsRead = async function(
  userId: Types.ObjectId,
  notificationIds: Types.ObjectId[] | string[]
): Promise<number> {
  const result = await this.updateMany(
    { 
      _id: { $in: notificationIds },
      userId: userId
    },
    {
      unread: false,
      readAt: new Date()
    }
  );
  
  return result.modifiedCount;
};

export default mongoose.model<INotification>('Notification', NotificationSchema);

src/models/payment-rate.model.ts
// backend/src/models/payment-rate.model.ts
import mongoose, { Document, Schema } from 'mongoose';

export interface IPaymentRate extends Document {
  countries: string[]; // Multiple countries
  country?: string; // For backward compatibility
  receiptDays: number;
  rateType: 'percentage' | 'fixed' | 'both';
  rateValue: number; // Used for percentage
  currencies?: { // Used for fixed amount
    USD?: number;
    BRL?: number;
  };
  isDefault?: boolean; // For backward compatibility
  createdAt: Date;
  updatedAt: Date;
}

const PaymentRateSchema = new Schema<IPaymentRate>(
  {
    countries: {
      type: [String],
      required: true,
    },
    country: {
      type: String, // For backward compatibility
    },
    receiptDays: {
      type: Number,
      required: true,
    },
    rateType: {
      type: String,
      enum: ['percentage', 'fixed', 'both'],
      default: 'percentage',
    },
    rateValue: {
      type: Number,
    },
    currencies: {
      USD: { type: Number },
      BRL: { type: Number },
    },
    isDefault: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: true,
  }
);

// For backward compatibility - populate 'country' from 'countries'
PaymentRateSchema.pre('save', function(next) {
  if (this.countries && this.countries.length > 0) {
    this.country = this.countries[0];
  }
  next();
});

// Remove compound index from previous version, as now we can have different rates for the same country & receipt days
// but with different currencies or rate types
PaymentRateSchema.index({ countries: 1, receiptDays: 1, rateType: 1 });

export default mongoose.model<IPaymentRate>('PaymentRate', PaymentRateSchema);

src/models/product.model.ts
// src/models/product.model.ts
// Model for products with support for digital/physical products, variants, and currency

import mongoose, { Document, Schema, Types } from 'mongoose';

export interface IVariant {
  name: string;
  values: string[];
  stock: number;
}

export interface IImage {
  url: string;
  isMain: boolean;
}

export interface IDigitalOptions {
  fileUrl?: string;
  fileUpload?: string;
  recurring?: {
    interval: 'monthly' | 'yearly';
    trialDays?: number;
    hasTrial: boolean;
  };
}

export interface IPhysicalOptions {
  weight?: number;  // in kg
  dimensions?: {
    length: number;
    width: number;
    height: number;
  };
  shippingClass?: string;
}

export interface IProduct extends Document {
  merchantId: Types.ObjectId;
  title: string;
  description: string;
  price: number;
  currency: string;  // Currency code (USD, BRL, EUR, etc.)
  type: 'digital' | 'physical';
  digital?: IDigitalOptions;
  physical?: IPhysicalOptions;
  variants?: IVariant[];
  images: IImage[];
  status: 'active' | 'deactivated' | 'deleted';
  listedAt: Date;
  delistedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const ProductSchema = new Schema<IProduct>(
  {
    merchantId: {
      type: Schema.Types.ObjectId,
      ref: 'Merchant',
      required: true,
      index: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
      minlength: 3,
      maxlength: 120,
    },
    description: {
      type: String,
      required: true,
      trim: true,
      maxlength: 4000,
    },
    price: {
      type: Number,
      required: true,
      min: 0.01,
    },
    currency: {
      type: String,
      required: true,
      uppercase: true,
      trim: true,
      // Common currencies (can be expanded later)
      enum: ['USD', 'BRL', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY'],
    },
    type: {
      type: String,
      required: true,
      enum: ['digital', 'physical'],
    },
    digital: {
      fileUrl: {
        type: String,
      },
      fileUpload: {
        type: String,
      },
      recurring: {
        interval: {
          type: String,
          enum: ['monthly', 'yearly'],
        },
        hasTrial: {
          type: Boolean,
          default: false
        },
        trialDays: {
          type: Number,
          min: 0,
          max: 90,
        },
      },
    },
    physical: {
      weight: {
        type: Number,
        min: 0,
      },
      dimensions: {
        length: { type: Number, min: 0 },
        width: { type: Number, min: 0 },
        height: { type: Number, min: 0 },
      },
      shippingClass: {
        type: String,
        trim: true,
      },
    },
    variants: [{
      name: {
        type: String,
        required: true,
        trim: true,
      },
      values: [{
        type: String,
        required: true,
        trim: true,
      }],
      stock: {
        type: Number,
        required: true,
        min: 0,
        default: 0,
      },
    }],
    images: [{
      url: {
        type: String,
        required: true,
        validate: {
          validator: function(v: string) {
            // Simple URL validation
            return /^(https?:\/\/)/.test(v);
          },
          message: props => `${props.value} is not a valid URL!`
        },
      },
      isMain: {
        type: Boolean,
        default: false
      }
    }],
    status: {
      type: String,
      enum: ['active', 'deactivated', 'deleted'],
      default: 'active',
    },
    listedAt: {
      type: Date,
      default: Date.now,
    },
    delistedAt: {
      type: Date,
      default: null,
    },
  },
  {
    timestamps: true,
  }
);

// Validation for digital product requirements
ProductSchema.path('digital.fileUrl').validate(function(this: any, fileUrl: string) {
    if (this.type === 'digital' && !fileUrl && !(this.digital && this.digital.fileUpload)) {
      return false;
    }
    return true;
  }, 'Digital products require either a file URL or file upload');

// Pre-save hook to ensure one main image
ProductSchema.pre('save', function(next) {
  // If there are no images, skip this validation
  if (!this.images || this.images.length === 0) {
    return next();
  }
  
  // Check if there's already a main image
  const mainImageExists = this.images.some(image => image.isMain);
  
  // If no main image exists, set the first image as main
  if (!mainImageExists && this.images.length > 0) {
    this.images[0].isMain = true;
  }
  
  // Ensure only one image is set as main
  let mainImageCount = 0;
  
  this.images.forEach(image => {
    if (image.isMain) {
      mainImageCount++;
    }
  });
  
  // If multiple main images, keep only the first one as main
  if (mainImageCount > 1) {
    let foundMain = false;
    
    this.images = this.images.map(image => {
      if (image.isMain) {
        if (!foundMain) {
          foundMain = true;
        } else {
          image.isMain = false;
        }
      }
      return image;
    });
  }
  
  next();
});

// Create useful indexes
ProductSchema.index({ merchantId: 1, status: 1 });
ProductSchema.index({ title: 'text', description: 'text' });
ProductSchema.index({ currency: 1 });
ProductSchema.index({ type: 1 });
ProductSchema.index({ listedAt: -1 });
ProductSchema.index({ price: 1 });

export default mongoose.model<IProduct>('Product', ProductSchema);

src/models/settings.model.ts
// src/models/settings.model.ts
// Model for system-wide settings that can be modified by admin

import mongoose, { Document, Schema } from 'mongoose';

export interface ISetting extends Document {
  key: string;
  value: any;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  description: string;
  updatedAt: Date;
  updatedBy?: string;
}

const SettingSchema = new Schema<ISetting>(
  {
    key: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,
    },
    value: {
      type: Schema.Types.Mixed,
      required: true,
    },
    type: {
      type: String,
      required: true,
      enum: ['string', 'number', 'boolean', 'object', 'array'],
    },
    description: {
      type: String,
      required: true,
      trim: true,
    },
    updatedBy: {
      type: String,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

// Static method to get setting by key
SettingSchema.statics.getByKey = async function(key: string): Promise<any> {
  const setting = await this.findOne({ key });
  return setting ? setting.value : null;
};

// Static method to set setting by key
SettingSchema.statics.setByKey = async function(key: string, value: any, updatedBy?: string): Promise<ISetting | null> {
  const setting = await this.findOne({ key });
  
  if (!setting) {
    return null;
  }
  
  setting.value = value;
  if (updatedBy) {
    setting.updatedBy = updatedBy;
  }
  
  return setting.save();
};

// Default settings initialization function
SettingSchema.statics.initDefaults = async function(): Promise<void> {
  const defaults = [
    {
      key: 'fxSpreadPercentDefault',
      value: 1.9,
      type: 'number',
      description: 'Default FX spread percentage applied to currency conversions',
    },
    {
      key: 'maxApiRPS',
      value: 20,
      type: 'number',
      description: 'Maximum API requests per second per client',
    },
    {
      key: 'payoutMinAmount',
      value: { USD: 50, BRL: 250 },
      type: 'object',
      description: 'Minimum amount for automatic payouts in each currency',
    },
    {
      key: 'productRateLimits',
      value: { 
        create: 20, 
        update: 50, 
        list: 100 
      },
      type: 'object',
      description: 'Rate limits for product API endpoints (per hour)',
    },
    {
      key: 'maintenanceMode',
      value: false,
      type: 'boolean',
      description: 'System-wide maintenance mode flag',
    },
    {
      key: 'allowedCurrencies',
      value: ['USD', 'BRL', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY'],
      type: 'array',
      description: 'List of allowed currencies for products',
    },
    {
      key: 'autoFxUpdate',
      value: true,
      type: 'boolean',
      description: 'Whether to automatically update FX rates daily',
    },
    {
      key: 'notificationRetentionDays',
      value: 90,
      type: 'number',
      description: 'Days to keep read notifications before cleanup',
    },
  ];

  for (const setting of defaults) {
    const exists = await this.findOne({ key: setting.key });
    if (!exists) {
      await this.create(setting);
    }
  }
};

export default mongoose.model<ISetting>('Setting', SettingSchema);

src/models/user.model.ts
// backend/src/models/user.model.ts
import mongoose, { Document, Schema, Types } from 'mongoose';
import bcrypt from 'bcrypt';

// Interface definition including the idCheckStatus field
export interface IUser extends Document {
  email: string;
  password: string;
  role: 'merchant' | 'admin';
  merchantId?: Types.ObjectId;
  emailVerifiedAt?: Date;
  phone?: string;
  dob?: Date;
  timezone: string;
  idCheckStatus?: 'pending' | 'verified' | 'rejected';
  status: 'active' | 'suspended' | 'blocked';
  suspendedUntil?: Date;
  onboardingStage: number;
  onboardingComplete: boolean;
  comparePassword: (password: string) => Promise<boolean>;
}

const UserSchema = new Schema<IUser>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
    },
    password: {
      type: String,
      required: true,
    },
    role: {
      type: String,
      enum: ['merchant', 'admin'],
      default: 'merchant',
    },
    merchantId: {
      type: Schema.Types.ObjectId,
      ref: 'Merchant',
    },
    emailVerifiedAt: {
      type: Date,
      default: null,
    },
    phone: {
      type: String,
    },
    dob: {
      type: Date,
    },
    timezone: {
      type: String,
      default: 'America/Sao_Paulo',
    },
    // Schema field definition for idCheckStatus (now optional)
    idCheckStatus: {
      type: String,
      enum: ['pending', 'verified', 'rejected'],
    },
    // User account status
    status: {
      type: String,
      enum: ['active', 'suspended', 'blocked'],
      default: 'active',
    },
    // Date until when the user is suspended
    suspendedUntil: {
      type: Date,
    },
    onboardingStage: {
      type: Number,
      default: 1, // 1: Basic Info, 2: Business Info, 3: Address, 4: Selling Method
    },
    onboardingComplete: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: true,
  }
);

// Hash password before saving
UserSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error: any) {
    next(error);
  }
});

// Method to compare password
UserSchema.methods.comparePassword = async function (password: string): Promise<boolean> {
  return bcrypt.compare(password, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);

src/models/verification.model.ts
// backend/src/models/verification.model.ts
import mongoose, { Document, Schema, Types } from 'mongoose';

export interface IDocument {
  type: string;
  number?: string;
  frontImage?: string;
  backImage?: string;
  selfieImage?: string;
  status: 'pending' | 'verified' | 'rejected';
  rejectionReason?: string;
  uploadedAt: Date;
  updatedAt?: Date;
  verifiedAt?: Date;
}

export interface IVerification extends Document {
  merchantId: Types.ObjectId;
  userId: Types.ObjectId;
  status: 'pending' | 'verified' | 'rejected';
  submittedAt: Date;
  updatedAt?: Date;
  verifiedAt?: Date;
  rejectionNote?: string; // Added this field
  
  // Business document
  businessDocument: {
    type: string; // EIN, SSN, CNPJ, CPF
    number: string;
    documentImage?: string;
    status: 'pending' | 'verified' | 'rejected';
    rejectionReason?: string;
  };
  
  // Personal document
  personalDocument: {
    type: string; // National ID, Driver's License, Passport
    number: string;
    frontImage?: string;
    backImage?: string;
    selfieImage?: string;
    status: 'pending' | 'verified' | 'rejected';
    rejectionReason?: string;
  };
  
  // Bank details
  bankDetails: {
    accountName: string;
    accountNumber: string;
    routingNumber?: string; // For US
    bankName: string;
    bankBranch?: string; // For Brazil
    statementDocument?: string;
    status: 'pending' | 'verified' | 'rejected';
    rejectionReason?: string;
  };
  
  // Payment settings
  paymentSettings: {
    receiptTime: 5 | 14;
    rateType: 'percentage' | 'fixed';
    rateValue: number;
    methods: {
      creditCard: boolean;
      paypal: boolean;
      wallets: boolean;
      pix: boolean;
    };
  };
}

const VerificationSchema = new Schema<IVerification>(
  {
    merchantId: {
      type: Schema.Types.ObjectId,
      ref: 'Merchant',
      required: true,
    },
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    status: {
      type: String,
      enum: ['pending', 'verified', 'rejected'],
      default: 'pending',
    },
    submittedAt: {
      type: Date,
      default: Date.now,
    },
    updatedAt: {
      type: Date,
    },
    verifiedAt: {
      type: Date,
    },
    rejectionNote: {
      type: String,
    },
    businessDocument: {
      type: {
        type: String,
        required: true,
      },
      number: {
        type: String,
        required: true,
      },
      documentImage: {
        type: String,
      },
      status: {
        type: String,
        enum: ['pending', 'verified', 'rejected'],
        default: 'pending',
      },
      rejectionReason: {
        type: String,
      },
    },
    personalDocument: {
      type: {
        type: String,
        required: true,
      },
      number: {
        type: String,
        required: true,
      },
      frontImage: {
        type: String,
      },
      backImage: {
        type: String,
      },
      selfieImage: {
        type: String,
      },
      status: {
        type: String,
        enum: ['pending', 'verified', 'rejected'],
        default: 'pending',
      },
      rejectionReason: {
        type: String,
      },
    },
    bankDetails: {
      accountName: {
        type: String,
        required: true,
      },
      accountNumber: {
        type: String,
        required: true,
      },
      routingNumber: {
        type: String,
      },
      bankName: {
        type: String,
        required: true,
      },
      bankBranch: {
        type: String,
      },
      statementDocument: {
        type: String,
      },
      status: {
        type: String,
        enum: ['pending', 'verified', 'rejected'],
        default: 'pending',
      },
      rejectionReason: {
        type: String,
      },
    },
    paymentSettings: {
      receiptTime: {
        type: Number,
        enum: [5, 14],
        default: 14,
      },
      rateType: {
        type: String,
        enum: ['percentage', 'fixed'],
        default: 'percentage',
      },
      rateValue: {
        type: Number,
        default: 0,
      },
      methods: {
        creditCard: {
          type: Boolean,
          default: true,
        },
        paypal: {
          type: Boolean,
          default: true,
        },
        wallets: {
          type: Boolean,
          default: true,
        },
        pix: {
          type: Boolean,
          default: true,
        },
      },
    },
  },
  {
    timestamps: true,
  }
);

export default mongoose.model<IVerification>('Verification', VerificationSchema);

src/modules/commerce/index.ts
// src/modules/commerce/index.ts
// Main entry point for commerce module, combining all routes

import { Router } from 'express';
import productRoutes from '../../routes/product.routes';
import financeRoutes from '../../routes/finance.routes';
import notificationRoutes from '../../routes/notification.routes';

const router = Router();

// Product routes
router.use('/products', productRoutes);

// Finance routes
router.use('/finance', financeRoutes);

// Notification routes
router.use('/notifications', notificationRoutes);

export default router;

src/routes/admin.routes.ts
// src/routes/admin.routes.ts
// Routes for admin operations - updated with new endpoints

import { Router } from 'express';
import {
  adminLogin,
  getPendingVerifications,
  getRejectedVerifications,
  getVerificationDetails,
  updateVerificationStatus,
  getDocumentFile,
  getPaymentRates,
  getPaymentRateById,
  updatePaymentRate,
  deletePaymentRate,
  getUsers,
  getUserDetails,
  suspendUser,
  blockUser,
  resubmitVerification,
  deleteUser,
  unverifyUser,
  editUserInfo,
  activateUser
} from '../controllers/admin.controller';

// Import admin product controllers
import {
  adminGetProducts,
  adminGetProductById,
  adminUpdateProduct,
  adminDeleteProduct,
  adminChangeProductCurrency,
  adminGetProductStats
} from '../controllers/admin.product.controller';

// Import admin balance/finance controllers
import {
  adminGetMerchantBalance,
  adminAdjustMerchantBalance,
  adminChangeMerchantCurrency,
  adminGetFxRates,
  adminUpdateFxSettings,
  adminForceUpdateFxRates,
  adminGetMerchantTransactions
} from '../controllers/admin.balance.controller';

// Import admin notification controllers
import {
  adminBroadcastNotification,
  adminDeleteUserNotifications
} from '../controllers/notification.controller';

import { authenticateAdmin, requireFullAccess } from '../middlewares/admin.middleware';

const router = Router();

// Public admin routes
router.post('/login', adminLogin as any);

// Protected admin routes - read-only access
router.use(authenticateAdmin as any);

// Verification read-only routes
router.get('/verifications/pending', getPendingVerifications as any);
router.get('/verifications/rejected', getRejectedVerifications as any);
router.get('/verifications/:id', getVerificationDetails as any);

// User management read-only routes
router.get('/users', getUsers as any);
router.get('/users/:id', getUserDetails as any);

// Payment rates read-only routes
router.get('/payment-rates', getPaymentRates as any);
router.get('/payment-rates/:id', getPaymentRateById as any);

// Document routes - use authenticateAdmin middleware to validate token but NOT requireFullAccess since that's checked in the controller
router.get('/documents/:type/:id', authenticateAdmin as any, getDocumentFile as any);
router.get('/documents/:type/:id/:field', authenticateAdmin as any, getDocumentFile as any);

// Product routes - read-only without full access
router.get('/products', adminGetProducts as any);
router.get('/products/stats', adminGetProductStats as any);
router.get('/products/:id', adminGetProductById as any);

// Finance routes - read-only without full access
router.get('/finance/:merchantId', adminGetMerchantBalance as any);
router.get('/finance/:merchantId/transactions', adminGetMerchantTransactions as any);
router.get('/finance/fx-rates', adminGetFxRates as any);

// Modification routes - require full access
// Verification modification
router.post('/verifications/:id/update', requireFullAccess as any, updateVerificationStatus as any);

// User modification
router.post('/users/:id/suspend', requireFullAccess as any, suspendUser as any);
router.post('/users/:id/block', requireFullAccess as any, blockUser as any);
router.post('/users/:id/activate', requireFullAccess as any, activateUser as any);
router.post('/users/:id/resubmit', requireFullAccess as any, resubmitVerification as any);
router.post('/users/:id/unverify', requireFullAccess as any, unverifyUser as any);
router.post('/users/:id/edit', requireFullAccess as any, editUserInfo as any);
router.post('/users/:id/delete', requireFullAccess as any, deleteUser as any);

// Payment rates modification
router.post('/payment-rates', requireFullAccess as any, updatePaymentRate as any);
router.post('/payment-rates/:id', requireFullAccess as any, updatePaymentRate as any);
router.delete('/payment-rates/:id', requireFullAccess as any, deletePaymentRate as any);

// Product modification
router.put('/products/:id', requireFullAccess as any, adminUpdateProduct as any);
router.delete('/products/:id', requireFullAccess as any, adminDeleteProduct as any);
router.patch('/products/:id/currency', requireFullAccess as any, adminChangeProductCurrency as any);

// Finance modification
router.patch('/finance/:merchantId/balance', requireFullAccess as any, adminAdjustMerchantBalance as any);
router.patch('/finance/:merchantId/currency', requireFullAccess as any, adminChangeMerchantCurrency as any);
router.patch('/settings/fx', requireFullAccess as any, adminUpdateFxSettings as any);
router.post('/finance/fx-rates/update', requireFullAccess as any, adminForceUpdateFxRates as any);

// Notification routes
router.post('/notifications/broadcast', requireFullAccess as any, adminBroadcastNotification as any);
router.delete('/notifications/user/:userId', requireFullAccess as any, adminDeleteUserNotifications as any);

export default router;

src/routes/auth.routes.ts
import { Router } from 'express';
import {
  register,
  login,
  getCurrentUser,
  verifyEmail,
  sendVerificationEmail,
  getVerificationStatus,
} from '../controllers/auth.controller';
import { authenticate } from '../middlewares/auth.middleware';

const router = Router();

// Public routes
router.post('/register', register as any);
router.post('/login', login as any);
router.get('/verify-email/:token', verifyEmail as any);

// Protected routes
router.get('/me', authenticate as any, getCurrentUser as any);
router.post('/send-verification-email', authenticate as any, sendVerificationEmail as any);
router.get('/verification-status', authenticate as any, getVerificationStatus as any);

export default router;

src/routes/finance.routes.ts
// src/routes/finance.routes.ts
// Routes for financial operations (balance, transactions, payouts)

import { Router } from 'express';
import {
  getBalance,
  getTransactions,
  requestPayout,
  getExchangeRates,
} from '../controllers/balance.controller';
import { authenticate, requireMerchantRole, requireOnboardingComplete, requireIdVerification } from '../middlewares/auth.middleware';

const router = Router();

// All routes are protected
router.use(authenticate as any);
router.use(requireMerchantRole as any);
router.use(requireOnboardingComplete as any);

// Balance and transactions can be accessed with just completed onboarding
router.get('/balance', getBalance as any);
router.get('/transactions', getTransactions as any);
router.get('/rates', getExchangeRates as any);

// Payout requests require ID verification
router.post('/payout', requireIdVerification as any, requestPayout as any);

export default router;

src/routes/notification.routes.ts
// src/routes/notification.routes.ts
// Routes for notification management

import { Router } from 'express';
import {
  getUserNotifications,
  markNotificationsAsRead,
  markAllNotificationsAsRead,
  deleteNotification,
} from '../controllers/notification.controller';
import { authenticate } from '../middlewares/auth.middleware';

const router = Router();

// All routes are protected
router.use(authenticate as any);

// Notification routes
router.get('/', getUserNotifications as any);
router.post('/read', markNotificationsAsRead as any);
router.post('/read-all', markAllNotificationsAsRead as any);
router.delete('/:id', deleteNotification as any);

export default router;

src/routes/onboarding.routes.ts
import { Router } from 'express';
import {
  updateBusinessInfo,
  updateAddress,
  updateSellingMethod,
  getOnboardingStatus,
} from '../controllers/onboarding.controller';
import { authenticate, requireMerchantRole } from '../middlewares/auth.middleware';

const router = Router();

// All routes are protected for merchants only
router.use(authenticate as any);
router.use(requireMerchantRole as any);

router.get('/status', getOnboardingStatus as any);
router.post('/business', updateBusinessInfo as any);
router.post('/address', updateAddress as any);
router.post('/selling-method', updateSellingMethod as any);

export default router;

src/routes/product.routes.ts
// src/routes/product.routes.ts
// Routes for product management

import { Router } from 'express';
import {
  createProduct,
  getMerchantProducts,
  getProductById,
  updateProduct,
  deleteProduct,
  getPublicProduct,
} from '../controllers/product.controller';
import { authenticate, requireMerchantRole } from '../middlewares/auth.middleware';

const router = Router();

// Public routes
router.get('/public/:id', getPublicProduct as any);

// Protected routes for merchants
router.use(authenticate as any);
router.use(requireMerchantRole as any);

router.post('/', createProduct as any);
router.get('/', getMerchantProducts as any);
router.get('/:id', getProductById as any);
router.put('/:id', updateProduct as any);
router.delete('/:id', deleteProduct as any);

export default router;

src/routes/verification.routes.ts
// backend/src/routes/verification.routes.ts
// Routes for merchant identity verification

import { Router } from 'express';
import { 
  getVerificationStatus,
  submitVerification,
  upload
} from '../controllers/verification.controller';
import { authenticate, requireMerchantRole } from '../middlewares/auth.middleware';

const router = Router();

// Protect all routes
router.use(authenticate as any);
router.use(requireMerchantRole as any);

// Get verification status
router.get('/status', getVerificationStatus as any);

// Submit verification documents
router.post(
  '/submit',
  upload.fields([
    { name: 'businessDocImage', maxCount: 1 },
    { name: 'personalDocFront', maxCount: 1 },
    { name: 'personalDocBack', maxCount: 1 },
    { name: 'personalSelfie', maxCount: 1 },
    { name: 'bankStatement', maxCount: 1 }
  ]),
  submitVerification as any
);

export default router;

src/server.ts
// src/server.ts
import app from './app';
import config from './config/default';
import connectDB from './config/db';
import logger from './utils/logger';
import InitService from './services/init.service';

const PORT = config.port;

// Start server
const startServer = async () => {
  try {
    // Connect to MongoDB
    await connectDB();
    
    // Initialize application settings and services
    await InitService.initialize();

    // Start Express server
    app.listen(PORT, () => {
      logger.info(`Server running in ${config.nodeEnv} mode on port ${PORT}`);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

src/services/auth.service.ts


src/services/balance.service.ts
// src/services/balance.service.ts
// Service for managing merchant balances, including reserve and available funds

import mongoose, { Types } from 'mongoose';
import BalanceModel, { IBalance } from '../models/balance.model';
import MerchantModel from '../models/merchant.model';
import FxService from './fx.service';
import logger from '../utils/logger';

export class BalanceService {
  /**
   * Initialize a merchant's balance if it doesn't exist
   * @param merchantId Merchant ID
   * @returns The merchant's balance document
   */
  public static async ensureBalanceExists(merchantId: string | Types.ObjectId): Promise<IBalance> {
    try {
      // Try to find existing balance
      let balance = await BalanceModel.findOne({ merchantId });
      
      // If it doesn't exist, create it
      if (!balance) {
        // Get merchant to determine dashboard currency
        const merchant = await MerchantModel.findById(merchantId);
        if (!merchant) {
          throw new Error(`Merchant not found: ${merchantId}`);
        }
        
        // Use the merchant's dashboardCurrency, fallback to defaultCurrency, then country-based default
        const dashboardCurrency = merchant.dashboardCurrency || merchant.defaultCurrency || (merchant.country === 'BR' ? 'BRL' : 'USD');
        
        // Create new balance with zero amounts
        balance = await BalanceModel.create({
          merchantId,
          dashboardCurrency,
          reserve: 0,
          available: 0,
          pending: 0,
        });
        
        logger.info(`Created new balance for merchant ${merchantId}`);
      }
      
      return balance;
    } catch (error) {
      logger.error(`Error ensuring balance exists: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Get a merchant's current balance
   * @param merchantId Merchant ID
   * @returns The merchant's balance
   */
  public static async getBalance(merchantId: string | Types.ObjectId): Promise<IBalance> {
    return this.ensureBalanceExists(merchantId);
  }

  /**
   * Add funds to a merchant's reserve balance (e.g., from a new order)
   * @param merchantId Merchant ID
   * @param amount Amount to add
   * @param currency Currency of the amount
   * @param reference Reference ID (e.g., order ID)
   * @returns Updated balance
   */
  public static async addToReserve(
    merchantId: string | Types.ObjectId, 
    amount: number, 
    currency: string,
    reference: string
  ): Promise<IBalance> {
    const session = await mongoose.startSession();
    
    try {
      session.startTransaction();
      
      // Get merchant to determine dashboard currency and FX spread
      const merchant = await MerchantModel.findById(merchantId);
      if (!merchant) {
        throw new Error(`Merchant not found: ${merchantId}`);
      }
      
      // Get or create balance
      const balance = await this.ensureBalanceExists(merchantId);
      
      // If currencies don't match, convert the amount
      let amountInDashboardCurrency = amount;
      
      if (currency !== balance.dashboardCurrency) {
        const { convertedAmount } = await FxService.convertCurrency(
          amount,
          currency,
          balance.dashboardCurrency,
          merchant.fxSpreadPercent
        );
        
        amountInDashboardCurrency = convertedAmount;
      }
      
      // Update reserve balance (rounding to 2 decimal places)
      const newReserve = parseFloat((balance.reserve + amountInDashboardCurrency).toFixed(2));
      
      // Update balance in database
      const updatedBalance = await BalanceModel.findByIdAndUpdate(
        balance._id,
        { reserve: newReserve },
        { new: true, session }
      );
      
      await session.commitTransaction();
      
      logger.info(
        `Added ${amountInDashboardCurrency} ${balance.dashboardCurrency} to reserve for merchant ${merchantId} (original: ${amount} ${currency}, reference: ${reference})`
      );
      
      return updatedBalance!;
    } catch (error) {
      await session.abortTransaction();
      logger.error(`Error adding to reserve: ${(error as Error).message}`);
      throw error;
    } finally {
      session.endSession();
    }
  }

  /**
   * Move funds from reserve to available (e.g., after hold period)
   * @param merchantId Merchant ID
   * @param amount Amount to move
   * @param reference Reference ID
   * @returns Updated balance
   */
  public static async moveFromReserveToAvailable(
    merchantId: string | Types.ObjectId, 
    amount: number,
    reference: string
  ): Promise<IBalance> {
    const session = await mongoose.startSession();
    
    try {
      session.startTransaction();
      
      // Get balance
      const balance = await BalanceModel.findOne({ merchantId });
      if (!balance) {
        throw new Error(`Balance not found for merchant ${merchantId}`);
      }
      
      // Verify sufficient funds in reserve
      if (balance.reserve < amount) {
        throw new Error(`Insufficient reserve balance: ${balance.reserve} < ${amount}`);
      }
      
      // Round to 2 decimal places
      const newReserve = parseFloat((balance.reserve - amount).toFixed(2));
      const newAvailable = parseFloat((balance.available + amount).toFixed(2));
      
      // Update balance in database
      const updatedBalance = await BalanceModel.findByIdAndUpdate(
        balance._id,
        { reserve: newReserve, available: newAvailable },
        { new: true, session }
      );
      
      await session.commitTransaction();
      
      logger.info(
        `Moved ${amount} ${balance.dashboardCurrency} from reserve to available for merchant ${merchantId} (reference: ${reference})`
      );
      
      return updatedBalance!;
    } catch (error) {
      await session.abortTransaction();
      logger.error(`Error moving funds from reserve to available: ${(error as Error).message}`);
      throw error;
    } finally {
      session.endSession();
    }
  }

  /**
   * Deduct funds from available balance (e.g., for payout)
   * @param merchantId Merchant ID
   * @param amount Amount to deduct
   * @param reference Reference ID
   * @returns Updated balance
   */
  public static async deductFromAvailable(
    merchantId: string | Types.ObjectId, 
    amount: number,
    reference: string
  ): Promise<IBalance> {
    const session = await mongoose.startSession();
    
    try {
      session.startTransaction();
      
      // Get balance
      const balance = await BalanceModel.findOne({ merchantId });
      if (!balance) {
        throw new Error(`Balance not found for merchant ${merchantId}`);
      }
      
      // Verify sufficient funds in available
      if (balance.available < amount) {
        throw new Error(`Insufficient available balance: ${balance.available} < ${amount}`);
      }
      
      // Round to 2 decimal places
      const newAvailable = parseFloat((balance.available - amount).toFixed(2));
      
      // Update balance in database
      const updatedBalance = await BalanceModel.findByIdAndUpdate(
        balance._id,
        { available: newAvailable },
        { new: true, session }
      );
      
      await session.commitTransaction();
      
      logger.info(
        `Deducted ${amount} ${balance.dashboardCurrency} from available for merchant ${merchantId} (reference: ${reference})`
      );
      
      return updatedBalance!;
    } catch (error) {
      await session.abortTransaction();
      logger.error(`Error deducting from available: ${(error as Error).message}`);
      throw error;
    } finally {
      session.endSession();
    }
  }

  /**
   * Handle refund by deducting from appropriate balance bucket
   * @param merchantId Merchant ID
   * @param amount Refund amount
   * @param currency Currency of the refund
   * @param reference Reference ID
   * @returns Updated balance
   */
  public static async handleRefund(
    merchantId: string | Types.ObjectId, 
    amount: number,
    currency: string,
    reference: string
  ): Promise<IBalance> {
    const session = await mongoose.startSession();
    
    try {
      session.startTransaction();
      
      // Get merchant to determine dashboard currency and FX spread
      const merchant = await MerchantModel.findById(merchantId);
      if (!merchant) {
        throw new Error(`Merchant not found: ${merchantId}`);
      }
      
      // Get balance
      const balance = await BalanceModel.findOne({ merchantId });
      if (!balance) {
        throw new Error(`Balance not found for merchant ${merchantId}`);
      }
      
      // Convert amount if needed
      let amountInDashboardCurrency = amount;
      
      if (currency !== balance.dashboardCurrency) {
        const { convertedAmount } = await FxService.convertCurrency(
          amount,
          currency,
          balance.dashboardCurrency,
          merchant.fxSpreadPercent
        );
        
        amountInDashboardCurrency = convertedAmount;
      }
      
      // Determine where to deduct from (reserve first, then available)
      let newReserve = balance.reserve;
      let newAvailable = balance.available;
      
      if (newReserve >= amountInDashboardCurrency) {
        // Sufficient funds in reserve - deduct from there
        newReserve = parseFloat((newReserve - amountInDashboardCurrency).toFixed(2));
      } else {
        // Deduct what we can from reserve
        const remainingAmount = amountInDashboardCurrency - newReserve;
        newReserve = 0;
        
        // Then deduct remainder from available
        if (newAvailable >= remainingAmount) {
          newAvailable = parseFloat((newAvailable - remainingAmount).toFixed(2));
        } else {
          // Not enough funds - this is a negative balance situation
          newAvailable = 0;
          logger.warning(
            `Refund creates negative balance for merchant ${merchantId}: ${amountInDashboardCurrency} > ${balance.reserve + balance.available}`
          );
        }
      }
      
      // Update balance in database
      const updatedBalance = await BalanceModel.findByIdAndUpdate(
        balance._id,
        { reserve: newReserve, available: newAvailable },
        { new: true, session }
      );
      
      await session.commitTransaction();
      
      logger.info(
        `Processed refund of ${amountInDashboardCurrency} ${balance.dashboardCurrency} for merchant ${merchantId} (reference: ${reference})`
      );
      
      return updatedBalance!;
    } catch (error) {
      await session.abortTransaction();
      logger.error(`Error handling refund: ${(error as Error).message}`);
      throw error;
    } finally {
      session.endSession();
    }
  }

  /**
   * Admin function to adjust a merchant's balance with an audit trail
   * @param merchantId Merchant ID
   * @param adjustments Adjustments to each balance bucket
   * @param reason Reason for adjustment
   * @param adminId Admin user ID
   * @returns Updated balance
   */
  public static async adminAdjustBalance(
    merchantId: string | Types.ObjectId,
    adjustments: {
      reserve?: number;
      available?: number;
      pending?: number;
    },
    reason: string,
    adminId: string
  ): Promise<IBalance> {
    const session = await mongoose.startSession();
    
    try {
      session.startTransaction();
      
      // Get balance
      const balance = await BalanceModel.findOne({ merchantId });
      if (!balance) {
        throw new Error(`Balance not found for merchant ${merchantId}`);
      }
      
      // Calculate new values (ensure we have at least 0)
      const updates: any = {};
      
      if (adjustments.reserve !== undefined) {
        updates.reserve = Math.max(0, parseFloat((balance.reserve + adjustments.reserve).toFixed(2)));
      }
      
      if (adjustments.available !== undefined) {
        updates.available = Math.max(0, parseFloat((balance.available + adjustments.available).toFixed(2)));
      }
      
      if (adjustments.pending !== undefined) {
        updates.pending = Math.max(0, parseFloat((balance.pending + adjustments.pending).toFixed(2)));
      }
      
      if (Object.keys(updates).length === 0) {
        throw new Error('No valid adjustments provided');
      }
      
      // Update balance in database
      const updatedBalance = await BalanceModel.findByIdAndUpdate(
        balance._id,
        updates,
        { new: true, session }
      );
      
      // Log adjustment for audit trail
      // In a real system, this would log to a dedicated audit collection
      logger.info(
        `Admin ${adminId} adjusted balance for merchant ${merchantId}: ${JSON.stringify(adjustments)} - Reason: ${reason}`
      );
      
      await session.commitTransaction();
      
      return updatedBalance!;
    } catch (error) {
      await session.abortTransaction();
      logger.error(`Error in admin balance adjustment: ${(error as Error).message}`);
      throw error;
    } finally {
      session.endSession();
    }
  }
}

export default BalanceService;

src/services/cron.service.ts
// src/services/cron.service.ts
// Service for handling scheduled jobs (reserve release, notification cleanup)

const cron = require('node-cron');
import BalanceService from './balance.service';
import NotificationService from './notification.service';
import MerchantModel from '../models/merchant.model';
import BalanceModel from '../models/balance.model';
import logger from '../utils/logger';

export class CronService {
  /**
   * Initialize all cron jobs:
   * - Release funds from reserve daily
   * - Cleanup notifications weekly
   */
  public static initializeJobs(): void {
    logger.info('Initializing cron jobs...');

    // Release funds from reserve at 02:00 UTC every day
    cron.schedule('0 2 * * *', () => {
      this.releaseFundsFromReserve();
    });

    // Cleanup old notifications at 03:00 UTC every Sunday
    cron.schedule('0 3 * * 0', () => {
      this.cleanupNotifications();
    });

    logger.info('Cron jobs initialized successfully');
  }

  /**
   * Release placeholder funds from reserve to available for each active merchant.
   */
  private static async releaseFundsFromReserve(): Promise<void> {
    try {
      logger.info('Running release funds from reserve job');

      const merchants = await MerchantModel.find({ status: 'active' });
      let totalProcessed = 0;
      let totalReleased = 0;

      for (const merchant of merchants) {
        try {
          // Placeholder logic: release up to 100 units per merchant
          const balance = await BalanceModel.findOne({ merchantId: merchant._id });
          if (balance && balance.reserve > 0) {
            const released = Math.min(balance.reserve, 100);
            await BalanceService.moveFromReserveToAvailable(
              merchant._id as string,
              released,
              'scheduled-release'
            );
            totalReleased += released;
          }
          totalProcessed++;
        } catch (err) {
          logger.error(
            `Error processing merchant ${merchant._id} for reserve release:`,
            err
          );
        }
      }

      logger.info(
        `Release funds job completed: processed ${totalProcessed} merchants, released ${totalReleased} total`
      );
    } catch (err) {
      logger.error('Error in release funds from reserve job:', err);
    }
  }

  /**
   * Delete read notifications older than retention period.
   */
  private static async cleanupNotifications(): Promise<void> {
    try {
      logger.info('Running notifications cleanup job');

      const retentionDays = 90;
      const deletedCount = await NotificationService.cleanupOldNotifications(retentionDays);

      logger.info(`Notifications cleanup completed: deleted ${deletedCount} old notifications`);
    } catch (err) {
      logger.error('Error in notifications cleanup job:', err);
    }
  }
}

export default CronService;


src/services/email.service.ts


src/services/fx.service.ts
// src/services/fx.service.ts
// Service for handling currency exchange rates stored in the database

import FxRateModel from '../models/fx-rate.model';
import SettingModel from '../models/settings.model';
import logger from '../utils/logger';

export class FxService {
  /**
   * Get current exchange rate from the database
   * @param baseCurrency Base currency code (e.g., 'USD')
   * @param quoteCurrency Quote currency code (e.g., 'BRL')
   * @returns The current exchange rate
   */
  public static async getCurrentRate(
    baseCurrency: string,
    quoteCurrency: string
  ): Promise<number> {
    baseCurrency = baseCurrency.toUpperCase();
    quoteCurrency = quoteCurrency.toUpperCase();

    // Same currency => rate 1
    if (baseCurrency === quoteCurrency) {
      return 1;
    }

    // Fetch the latest active rate snapshot from MongoDB
    const record = await (FxRateModel as any).getCurrentRate(
      baseCurrency,
      quoteCurrency
    );

    if (record) {
      return record.rate;
    }

    throw new Error(`Exchange rate for ${baseCurrency}/${quoteCurrency} not found`);
  }

  /**
   * Snapshot a provided rate into the database
   * @param baseCurrency Base currency code
   * @param quoteCurrency Quote currency code
   * @param rate The rate to store
   */
  public static async takeRateSnapshot(
    baseCurrency: string,
    quoteCurrency: string,
    rate: number
  ): Promise<void> {
    try {
      await (FxRateModel as any).snapshotRate(
        baseCurrency.toUpperCase(),
        quoteCurrency.toUpperCase(),
        rate,
        'manual'
      );
      logger.info(
        `Manual FX rate snapshot taken: ${baseCurrency.toUpperCase()}/${quoteCurrency.toUpperCase()} = ${rate}`
      );
    } catch (error) {
      logger.error(`Failed to snapshot FX rate: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Apply FX spread to a rate based on merchant or global settings
   * @param rate Base exchange rate
   * @param merchantSpreadPct Optional merchant-specific spread percentage
   * @returns Rate after spread applied
   */
  public static async applySpread(
    rate: number,
    merchantSpreadPct?: number | null
  ): Promise<number> {
    try {
      // If merchant-specific spread provided, use it
      if (merchantSpreadPct != null) {
        return rate * (1 - merchantSpreadPct / 100);
      }
      // Otherwise use global default spread
      const defaultSpreadPct =
        (await (SettingModel as any).getByKey('fxSpreadPercentDefault')) || 1.9;
      return rate * (1 - defaultSpreadPct / 100);
    } catch (error) {
      logger.error(`Error applying FX spread: ${(error as Error).message}`);
      // Fallback to a safe default spread of 1.5%
      return rate * 0.985;
    }
  }

  /**
   * Convert an amount from one currency to another, applying spread
   * @param amount Amount to convert
   * @param fromCurrency Source currency code
   * @param toCurrency Target currency code
   * @param merchantSpreadPct Optional merchant-specific spread
   * @returns Object containing convertedAmount and effectiveRate
   */
  public static async convertCurrency(
    amount: number,
    fromCurrency: string,
    toCurrency: string,
    merchantSpreadPct?: number | null
  ): Promise<{ convertedAmount: number; effectiveRate: number }> {
    // No conversion needed if currencies match
    if (fromCurrency.toUpperCase() === toCurrency.toUpperCase()) {
      return { convertedAmount: amount, effectiveRate: 1 };
    }

    // Retrieve the base rate
    const baseRate = await this.getCurrentRate(fromCurrency, toCurrency);
    // Apply spread
    const effectiveRate = await this.applySpread(baseRate, merchantSpreadPct);
    // Compute converted amount, rounded to 2 decimals
    const convertedAmount = parseFloat((amount * effectiveRate).toFixed(2));

    return { convertedAmount, effectiveRate };
  }
}

export default FxService;


src/services/init.service.ts
// src/services/init.service.ts
// Service for initializing application settings and defaults (FX initialization is now manual)

import SettingModel from '../models/settings.model';
import CronService from './cron.service';
import logger from '../utils/logger';

export class InitService {
  /**
   * Initialize the application
   * - Set up default settings
   * - Start cron jobs (FX jobs removed; rates are managed manually via admin endpoint)
   */
  public static async initialize(): Promise<void> {
    try {
      logger.info('Initializing application...');

      // Initialize default settings
      await this.initializeSettings();

      // Skip automatic FX initialization
      logger.info(
        'Skipping automatic FX rates initialization; rates will be managed manually via admin endpoint'
      );

      // Start cron jobs
      CronService.initializeJobs();

      logger.info('Application initialized successfully');
    } catch (error) {
      logger.error('Error initializing application:', error);
      throw error;
    }
  }

  /**
   * Initialize default settings
   */
  private static async initializeSettings(): Promise<void> {
    try {
      logger.info('Initializing default settings...');

      // Ensure settings collection exists and has defaults
      await (SettingModel as any).initDefaults();

      logger.info('Default settings initialized successfully');
    } catch (error) {
      logger.error('Error initializing default settings:', error);
      throw error;
    }
  }
}

export default InitService;


src/services/notification.service.ts
// src/services/notification.service.ts
// Service for handling user notifications and system-wide announcements

import { Types } from 'mongoose';
import NotificationModel, { INotification, NotificationType } from '../models/notification.model';
import UserModel from '../models/user.model';
import logger from '../utils/logger';

export class NotificationService {
  /**
   * Create a notification for a specific user
   * @param userId User ID
   * @param type Notification type
   * @param title Notification title
   * @param body Notification body
   * @param metadata Additional metadata
   * @returns Created notification
   */
  public static async createNotification(
    userId: string | Types.ObjectId,
    type: NotificationType,
    title: string,
    body: string,
    metadata: Record<string, any> = {}
  ): Promise<INotification> {
    try {
      // Create notification
      const notification = await NotificationModel.create({
        userId,
        type,
        title,
        body,
        unread: true,
        metadata,
      });
      
      logger.info(`Created notification for user ${userId}: ${type} - ${title}`);
      
      return notification;
    } catch (error) {
      logger.error(`Error creating notification: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Get notifications for a user
   * @param userId User ID
   * @param options Query options
   * @returns Notifications and pagination metadata
   */
  public static async getUserNotifications(
    userId: string | Types.ObjectId,
    options: {
      page?: number;
      limit?: number;
      unreadOnly?: boolean;
      type?: NotificationType;
    } = {}
  ): Promise<{ notifications: INotification[]; total: number; unreadCount: number }> {
    try {
      // Default options
      const page = options.page || 1;
      const limit = options.limit || 20;
      const skip = (page - 1) * limit;
      
      // Build query
      const query: any = { userId };
      
      if (options.unreadOnly) {
        query.unread = true;
      }
      
      if (options.type) {
        query.type = options.type;
      }
      
      // Get notifications with pagination
      const notifications = await NotificationModel.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit);
      
      // Get total count
      const total = await NotificationModel.countDocuments(query);
      
      // Get unread count
      const unreadCount = await NotificationModel.countDocuments({ 
        userId, 
        unread: true 
      });
      
      return {
        notifications,
        total,
        unreadCount,
      };
    } catch (error) {
      logger.error(`Error getting user notifications: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Mark notifications as read
   * @param userId User ID
   * @param notificationIds Array of notification IDs to mark as read
   * @returns Number of notifications marked as read
   */
  public static async markAsRead(
    userId: string | Types.ObjectId,
    notificationIds: (string | Types.ObjectId)[]
  ): Promise<number> {
    try {
      if (!notificationIds.length) {
        return 0;
      }
      
      // Update notifications
      const result = await NotificationModel.updateMany(
        {
          _id: { $in: notificationIds },
          userId,
          unread: true,
        },
        {
          unread: false,
          readAt: new Date(),
        }
      );
      
      logger.info(`Marked ${result.modifiedCount} notifications as read for user ${userId}`);
      
      return result.modifiedCount;
    } catch (error) {
      logger.error(`Error marking notifications as read: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Mark all notifications as read for a user
   * @param userId User ID
   * @returns Number of notifications marked as read
   */
  public static async markAllAsRead(userId: string | Types.ObjectId): Promise<number> {
    try {
      // Update all unread notifications
      const result = await NotificationModel.updateMany(
        {
          userId,
          unread: true,
        },
        {
          unread: false,
          readAt: new Date(),
        }
      );
      
      logger.info(`Marked all ${result.modifiedCount} notifications as read for user ${userId}`);
      
      return result.modifiedCount;
    } catch (error) {
      logger.error(`Error marking all notifications as read: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Delete a notification
   * @param userId User ID
   * @param notificationId Notification ID
   * @returns Boolean indicating success
   */
  public static async deleteNotification(
    userId: string | Types.ObjectId,
    notificationId: string | Types.ObjectId
  ): Promise<boolean> {
    try {
      // Delete notification (only if it belongs to the user)
      const result = await NotificationModel.deleteOne({
        _id: notificationId,
        userId,
      });
      
      if (result.deletedCount === 0) {
        throw new Error('Notification not found or does not belong to the user');
      }
      
      logger.info(`Deleted notification ${notificationId} for user ${userId}`);
      
      return true;
    } catch (error) {
      logger.error(`Error deleting notification: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Admin function to broadcast a notification to multiple users
   * @param type Notification type
   * @param title Notification title
   * @param body Notification body
   * @param options Target options
   * @param adminId Admin user ID for audit
   * @returns Number of notifications created
   */
  public static async adminBroadcastNotification(
    type: NotificationType,
    title: string,
    body: string,
    options: {
      role?: 'merchant' | 'admin';
      country?: 'US' | 'BR';
      userIds?: (string | Types.ObjectId)[];
    },
    adminId: string
  ): Promise<number> {
    try {
      // Build query to find target users
      const query: any = {};
      
      if (options.role) {
        query.role = options.role;
      }
      
      if (options.userIds && options.userIds.length > 0) {
        query._id = { $in: options.userIds };
      }
      
      // If country filter, we need to join with merchant data
      let users = [];
      if (options.country) {
        users = await UserModel.aggregate([
          {
            $lookup: {
              from: 'merchants',
              localField: 'merchantId',
              foreignField: '_id',
              as: 'merchant',
            },
          },
          {
            $match: {
              ...query,
              'merchant.country': options.country,
            },
          },
          {
            $project: {
              _id: 1,
            },
          },
        ]);
      } else {
        users = await UserModel.find(query).select('_id');
      }
      
      if (users.length === 0) {
        return 0;
      }
      
      // Create notifications in bulk
      const notifications = users.map(user => ({
        userId: user._id,
        type,
        title,
        body,
        unread: true,
        metadata: {
          isSystemBroadcast: true,
          broadcastBy: adminId,
        },
      }));
      
      // Insert notifications
      const result = await NotificationModel.insertMany(notifications);
      
      logger.info(`Admin ${adminId} broadcasted notification to ${result.length} users: ${type} - ${title}`);
      
      return result.length;
    } catch (error) {
      logger.error(`Error in admin broadcast: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Admin function to delete notifications for a user
   * @param userId User ID
   * @param adminId Admin user ID for audit
   * @returns Number of notifications deleted
   */
  public static async adminDeleteUserNotifications(
    userId: string | Types.ObjectId,
    adminId: string
  ): Promise<number> {
    try {
      // Delete all notifications for the user
      const result = await NotificationModel.deleteMany({ userId });
      
      logger.info(`Admin ${adminId} deleted ${result.deletedCount} notifications for user ${userId}`);
      
      return result.deletedCount;
    } catch (error) {
      logger.error(`Error in admin notification deletion: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Cleanup expired or old read notifications
   * @param daysToKeepRead Days to keep read notifications
   * @returns Number of notifications deleted
   */
  public static async cleanupOldNotifications(daysToKeepRead: number = 90): Promise<number> {
    try {
      // Calculate cutoff date
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeepRead);
      
      // Delete old read notifications
      const result = await NotificationModel.deleteMany({
        unread: false,
        readAt: { $lt: cutoffDate },
      });
      
      logger.info(`Cleaned up ${result.deletedCount} old read notifications (older than ${daysToKeepRead} days)`);
      
      return result.deletedCount;
    } catch (error) {
      logger.error(`Error cleaning up old notifications: ${(error as Error).message}`);
      throw error;
    }
  }
}

export default NotificationService;

src/services/product.service.ts
// src/services/product.service.ts
// Service for managing product listings and queries

import { Types } from 'mongoose';
import ProductModel, { IProduct } from '../models/product.model';
import UserModel from '../models/user.model';
import MerchantModel from '../models/merchant.model';
import SettingModel from '../models/settings.model';
import logger from '../utils/logger';

export class ProductService {
  /**
   * Check if a user is allowed to create or modify products
   * @param userId User ID to check
   * @returns Boolean indicating if user can create/modify products
   */
  public static async canCreateProducts(userId: string | Types.ObjectId): Promise<boolean> {
    try {
      // Find user with both status checks
      const user = await UserModel.findById(userId);
      
      if (!user) {
        return false;
      }
      
      // Both email verification and ID verification are required
      if (!user.emailVerifiedAt || user.idCheckStatus !== 'verified') {
        return false;
      }
      
      return true;
    } catch (error) {
      logger.error(`Error checking product creation permissions: ${(error as Error).message}`);
      return false;
    }
  }

  /**
   * Create a new product
   * @param userId User ID of the creator
   * @param productData Product data
   * @returns Created product
   */
  public static async createProduct(userId: string | Types.ObjectId, productData: Partial<IProduct>): Promise<IProduct> {
    try {
      // Check if user can create products
      const canCreate = await this.canCreateProducts(userId);
      if (!canCreate) {
        throw new Error('User is not eligible to create products. Both email and ID verification are required.');
      }
      
      // Find user's merchant ID
      const user = await UserModel.findById(userId);
      if (!user || !user.merchantId) {
        throw new Error('User does not have a merchant profile');
      }
      
      // Validate allowed currencies
      const allowedCurrencies = await (SettingModel as any).getByKey('allowedCurrencies') || 
        ['USD', 'BRL', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY'];
      
      if (!allowedCurrencies.includes(productData.currency?.toUpperCase() || '')) {
        throw new Error(`Currency not supported. Allowed currencies: ${allowedCurrencies.join(', ')}`);
      }
      
      // Create new product
      const newProduct = await ProductModel.create({
        ...productData,
        merchantId: user.merchantId,
        status: 'active',
        listedAt: new Date(),
      });
      
      logger.info(`Created product ${newProduct._id} for merchant ${user.merchantId}`);
      
      return newProduct;
    } catch (error) {
      logger.error(`Error creating product: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Get products for a merchant (with pagination)
   * @param merchantId Merchant ID
   * @param options Query options (pagination, filters)
   * @returns Products and pagination metadata
   */
  public static async getMerchantProducts(
    merchantId: string | Types.ObjectId,
    options: {
      page?: number;
      limit?: number;
      status?: 'active' | 'deactivated' | 'deleted';
      type?: 'digital' | 'physical';
      currency?: string;
      search?: string;
      sortBy?: string;
      sortOrder?: 'asc' | 'desc';
    } = {}
  ): Promise<{ products: IProduct[]; total: number; page: number; pages: number }> {
    try {
      // Default options
      const page = options.page || 1;
      const limit = options.limit || 10;
      const skip = (page - 1) * limit;
      
      // Build query
      const query: any = { merchantId };
      
      // Add filters if provided
      if (options.status) {
        query.status = options.status;
      } else {
        // Default to not showing deleted products
        query.status = { $ne: 'deleted' };
      }
      
      if (options.type) {
        query.type = options.type;
      }
      
      if (options.currency) {
        query.currency = options.currency.toUpperCase();
      }
      
      if (options.search) {
        query.$or = [
          { title: { $regex: options.search, $options: 'i' } },
          { description: { $regex: options.search, $options: 'i' } },
        ];
      }
      
      // Build sort
      const sort: any = {};
      const sortBy = options.sortBy || 'createdAt';
      const sortOrder = options.sortOrder === 'asc' ? 1 : -1;
      sort[sortBy] = sortOrder;
      
      // Execute query with pagination
      const products = await ProductModel.find(query)
        .sort(sort)
        .skip(skip)
        .limit(limit);
      
      // Get total count for pagination
      const total = await ProductModel.countDocuments(query);
      
      // Calculate total pages
      const pages = Math.ceil(total / limit);
      
      return {
        products,
        total,
        page,
        pages,
      };
    } catch (error) {
      logger.error(`Error getting merchant products: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Get a single product by ID
   * @param productId Product ID
   * @returns Product or null if not found
   */
  public static async getProductById(productId: string | Types.ObjectId): Promise<IProduct | null> {
    try {
      return await ProductModel.findById(productId);
    } catch (error) {
      logger.error(`Error getting product by ID: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Update a product
   * @param productId Product ID
   * @param userId User ID attempting the update
   * @param updates Updates to apply
   * @returns Updated product
   */
  public static async updateProduct(
    productId: string | Types.ObjectId,
    userId: string | Types.ObjectId,
    updates: Partial<IProduct>
  ): Promise<IProduct | null> {
    try {
      // Check if user can modify products
      const canCreate = await this.canCreateProducts(userId);
      if (!canCreate) {
        throw new Error('User is not eligible to modify products. Both email and ID verification are required.');
      }
      
      // Find user's merchant ID
      const user = await UserModel.findById(userId);
      if (!user || !user.merchantId) {
        throw new Error('User does not have a merchant profile');
      }
      
      // Find product and verify ownership
      const product = await ProductModel.findById(productId);
      if (!product) {
        throw new Error('Product not found');
      }
      
      if (product.merchantId.toString() !== user.merchantId.toString()) {
        throw new Error('You do not have permission to modify this product');
      }
      
      // Check if product is deleted
      if (product.status === 'deleted') {
        throw new Error('Cannot update a deleted product');
      }
      
      // Apply updates (allow only certain fields to be updated)
      const allowedUpdates = [
        'title',
        'description',
        'price',
        'images',
        'variants',
        'status',
        'physical',
        'digital',
      ];
      
      // Create a filtered update object
      const filteredUpdates: any = {};
      for (const key of allowedUpdates) {
        if (key in updates) {
          filteredUpdates[key] = (updates as any)[key];
        }
      }
      
      // Special treatment for status changes
      if (updates.status === 'deactivated') {
        filteredUpdates.delistedAt = new Date();
      } else if (updates.status === 'active' && product.status === 'deactivated') {
        filteredUpdates.delistedAt = null;
        filteredUpdates.listedAt = new Date();
      }
      
      // Update product
      const updatedProduct = await ProductModel.findByIdAndUpdate(
        productId,
        filteredUpdates,
        { new: true }
      );
      
      logger.info(`Updated product ${productId} for merchant ${user.merchantId}`);
      
      return updatedProduct;
    } catch (error) {
      logger.error(`Error updating product: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Delete a product (soft delete)
   * @param productId Product ID
   * @param userId User ID attempting the deletion
   * @returns Deleted product
   */
  public static async deleteProduct(
    productId: string | Types.ObjectId,
    userId: string | Types.ObjectId
  ): Promise<IProduct | null> {
    try {
      // Find user's merchant ID
      const user = await UserModel.findById(userId);
      if (!user || !user.merchantId) {
        throw new Error('User does not have a merchant profile');
      }
      
      // Find product and verify ownership
      const product = await ProductModel.findById(productId);
      if (!product) {
        throw new Error('Product not found');
      }
      
      if (product.merchantId.toString() !== user.merchantId.toString()) {
        throw new Error('You do not have permission to delete this product');
      }
      
      // Soft delete by updating status
      const deletedProduct = await ProductModel.findByIdAndUpdate(
        productId,
        {
          status: 'deleted',
          delistedAt: new Date(),
        },
        { new: true }
      );
      
      logger.info(`Deleted product ${productId} for merchant ${user.merchantId}`);
      
      return deletedProduct;
    } catch (error) {
      logger.error(`Error deleting product: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Admin function to get all products with advanced filtering
   * @param options Query options
   * @returns Products and pagination metadata
   */
  public static async adminGetProducts(
    options: {
      page?: number;
      limit?: number;
      status?: 'active' | 'deactivated' | 'deleted';
      type?: 'digital' | 'physical';
      currency?: string;
      search?: string;
      merchantId?: string;
      sortBy?: string;
      sortOrder?: 'asc' | 'desc';
      fromDate?: Date;
      toDate?: Date;
      priceMin?: number;
      priceMax?: number;
    } = {}
  ): Promise<{ products: IProduct[]; total: number; page: number; pages: number }> {
    try {
      // Default options
      const page = options.page || 1;
      const limit = options.limit || 20;
      const skip = (page - 1) * limit;
      
      // Build query
      const query: any = {};
      
      // Add filters if provided
      if (options.status) {
        query.status = options.status;
      }
      
      if (options.type) {
        query.type = options.type;
      }
      
      if (options.currency) {
        query.currency = options.currency.toUpperCase();
      }
      
      if (options.merchantId) {
        query.merchantId = options.merchantId;
      }
      
      if (options.search) {
        query.$or = [
          { title: { $regex: options.search, $options: 'i' } },
          { description: { $regex: options.search, $options: 'i' } },
        ];
      }
      
      // Date range filter
      if (options.fromDate || options.toDate) {
        query.createdAt = {};
        
        if (options.fromDate) {
          query.createdAt.$gte = options.fromDate;
        }
        
        if (options.toDate) {
          query.createdAt.$lte = options.toDate;
        }
      }
      
      // Price range filter
      if (options.priceMin !== undefined || options.priceMax !== undefined) {
        query.price = {};
        
        if (options.priceMin !== undefined) {
          query.price.$gte = options.priceMin;
        }
        
        if (options.priceMax !== undefined) {
          query.price.$lte = options.priceMax;
        }
      }
      
      // Build sort
      const sort: any = {};
      const sortBy = options.sortBy || 'createdAt';
      const sortOrder = options.sortOrder === 'asc' ? 1 : -1;
      sort[sortBy] = sortOrder;
      
      // Execute query with pagination
      const products = await ProductModel.find(query)
        .sort(sort)
        .skip(skip)
        .limit(limit);
      
      // Get total count for pagination
      const total = await ProductModel.countDocuments(query);
      
      // Calculate total pages
      const pages = Math.ceil(total / limit);
      
      return {
        products,
        total,
        page,
        pages,
      };
    } catch (error) {
      logger.error(`Error in admin product query: ${(error as Error).message}`);
      throw error;
    }
  }

  /**
   * Admin function to update a product (no ownership check)
   * @param productId Product ID
   * @param updates Updates to apply
   * @param adminId Admin user ID for audit
   * @returns Updated product
   */
  public static async adminUpdateProduct(
    productId: string | Types.ObjectId,
    updates: Partial<IProduct>,
    adminId: string
  ): Promise<IProduct | null> {
    try {
      // Find product
      const product = await ProductModel.findById(productId);
      if (!product) {
        throw new Error('Product not found');
      }
      
      // Apply updates directly (admins can update all fields)
      const updatedProduct = await ProductModel.findByIdAndUpdate(
        productId,
        updates,
        { new: true }
      );
      
      // Log admin action for audit trail
      logger.info(`Admin ${adminId} updated product ${productId} (merchant: ${product.merchantId})`);
      
      return updatedProduct;
    } catch (error) {
      logger.error(`Error in admin product update: ${(error as Error).message}`);
      throw error;
    }
  }
  
  /**
   * Get public product details (for checkout/public view)
   * @param productId Product ID
   * @returns Public product information
   */
  public static async getPublicProductDetails(
    productId: string | Types.ObjectId
  ): Promise<Partial<IProduct> | null> {
    try {
      // Find active product
      const product = await ProductModel.findOne({
        _id: productId,
        status: 'active'
      });
      
      if (!product) {
        return null;
      }
      
      // Return only public fields
      return {
        _id: product._id,
        title: product.title,
        description: product.description,
        price: product.price,
        currency: product.currency,
        type: product.type,
        variants: product.variants,
        images: product.images,
        // Don't include merchantId or other sensitive fields
      };
    } catch (error) {
      logger.error(`Error getting public product details: ${(error as Error).message}`);
      throw error;
    }
  }
}

export default ProductService;

src/types/index.ts


src/utils/logger.ts
const logger = {
    info: (message: string, ...args: any[]) => {
      console.log(`[INFO] ${message}`, ...args);
    },
    error: (message: string, ...args: any[]) => {
      console.error(`[ERROR] ${message}`, ...args);
    },
    warning: (message: string, ...args: any[]) => {
      console.warn(`[WARNING] ${message}`, ...args);
    },
    debug: (message: string, ...args: any[]) => {
      if (process.env.NODE_ENV !== 'production') {
        console.debug(`[DEBUG] ${message}`, ...args);
      }
    }
  };
  
  export default logger;

src/utils/response.ts
import { Response } from 'express';

interface SuccessResponse {
  success: true;
  message?: string;
  data?: any;
}

interface ErrorResponse {
  success: false;
  message: string;
  errors?: any;
}

export const successResponse = (res: Response, message: string = 'Success', data: any = null, statusCode: number = 200): Response => {
  const response: SuccessResponse = {
    success: true,
    message,
  };
  
  if (data) {
    response.data = data;
  }
  
  return res.status(statusCode).json(response);
};

export const errorResponse = (res: Response, message: string = 'Error', errors: any = null, statusCode: number = 400): Response => {
  const response: ErrorResponse = {
    success: false,
    message,
  };
  
  if (errors) {
    response.errors = errors;
  }
  
  return res.status(statusCode).json(response);
};

